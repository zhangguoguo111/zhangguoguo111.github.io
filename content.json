{"meta":{"title":"张果果的博客","subtitle":"","description":"","author":"张果果的博客","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"二叉树","slug":"二叉树","date":"2020-04-03T13:49:49.000Z","updated":"2020-04-07T13:18:27.033Z","comments":true,"path":"2020/04/03/二叉树/","link":"","permalink":"http://yoursite.com/2020/04/03/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"二叉树之重建二叉树题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。","text":"二叉树之重建二叉树题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root&#x3D;reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; &#x2F;&#x2F;前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; &#x2F;&#x2F;pre前序列表，mid 中序列表， &#x2F;&#x2F;startPre前序的开始序列,endPre前序的结束序列 &#x2F;&#x2F;startMid 中序的开始序列,endMid 中序的结束序列 &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;&#x2F;【整理思路】：根据先序和中序序列来构建树及其左右子树 private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre, int [] mid,int startMid,int endMid) &#123; &#x2F;&#x2F;左右子树构建完成 if(startPre&gt;endPre||startMid&gt;endMid) return null; &#x2F;&#x2F;1、先序遍历中确定root节点 TreeNode root&#x3D;new TreeNode(pre[startPre]); &#x2F;&#x2F;2、中序遍历中寻找root节点，然后构建当前root的左右子树root.left root.right， for(int i &#x3D; startMid;i &lt;&#x3D; endMid;i++) &#123; &#x2F;&#x2F;3、中序遍历找到root节点后，确定了左右子树的节点列表，然后用同样的方式(递归)构建左右子树即可 if(mid[i] &#x3D;&#x3D; pre[startPre])&#123; &#x2F;&#x2F;4、关键点：理解先序和中序start和end索引值的计算 &#x2F;&#x2F;中序的start end很好计算 &#x2F;&#x2F;先序的start end计算方式： 先计算中序的左子树长度，再根据这个长度i-startMid计算先序的start end &#x2F;&#x2F;startPre+(i-startMid)为先序中左子树的end位置,再加上1就是先序的右子树start索引值 root.left&#x3D;reConstructBinaryTree(pre,startPre+1,startPre+(i-startMid),mid,startMid,i-1); root.right&#x3D;reConstructBinaryTree(pre,startPre+(i-startMid)+1,endPre,mid,i+1,endMid); break; &#125; &#125; return root; &#125;&#125; 二叉树之树的子结构题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）思路比较简单，就是在A中递归查找是否有B的root节点，有的话再判断该节点的左右节点和B中root的左右节点是否相等。 12345678910111213141516171819202122232425262728293031public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean result &#x3D; false; if(root1 !&#x3D; null &amp;&amp; root2 !&#x3D; null)&#123; &#x2F;&#x2F;如果root节点相同 if(root1.val &#x3D;&#x3D; root2.val)&#123; &#x2F;&#x2F;判断左右子节点是否相同 result &#x3D; DoesTree1HasTree2(root1,root2); &#125; &#x2F;&#x2F;如果当前层没有找到与B相同的子结构，则继续递归左右子树中寻找 if(!result) &#123; result &#x3D; HasSubtree(root1.left,root2);&#x2F;&#x2F;左子树寻找相同的根节点 &#125; if(!result)&#123; result &#x3D; HasSubtree(root1.right,root2);&#x2F;&#x2F;右子树寻找相同的根节点 &#125; &#125; return result; &#125; public boolean DoesTree1HasTree2(TreeNode root1,TreeNode root2)&#123; if(root2 &#x3D;&#x3D; null) return true;&#x2F;&#x2F;递归终止条件，B已经到达叶子节点了，说明已经匹配成功！ if(root1 &#x3D;&#x3D; null) return false; if(root1.val !&#x3D; root2.val) return false; return DoesTree1HasTree2(root1.left,root2.left) &amp;&amp; DoesTree1HasTree2(root1.right,root2.right); &#125; &#125; 二叉树之二叉树的镜像题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。Java递归版本： 123456789101112131415public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root &#x3D;&#x3D; null || (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null)) return; &#x2F;&#x2F;左右子节点交换 TreeNode temp &#x3D; root.left; root.left &#x3D; root.right; root.right &#x3D; temp; if(root.left !&#x3D; null) Mirror(root.left);&#x2F;&#x2F;左子节点递归上述操作 if(root.right !&#x3D; null) Mirror(root.right);&#x2F;&#x2F;右子节点递归上述操作 &#125;&#125; Java 非递归版本： 123456789101112131415161718192021public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root &#x3D;&#x3D; null || (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null)) return; Stack&lt;TreeNode&gt; s &#x3D; new Stack&lt;&gt;(); s.push(root); while(!s.empty())&#123; TreeNode node &#x3D; s.pop(); &#x2F;&#x2F;左右子节点交换 TreeNode temp &#x3D; node.left; node.left &#x3D; node.right; node.right &#x3D; temp; if(node.left !&#x3D; null) s.push(node.left);&#x2F;&#x2F;左子节点递归上述操作 if(node.right !&#x3D; null) s.push(node.right);&#x2F;&#x2F;右子节点递归上述操作 &#125; &#125;&#125; 二叉树之从上往下打印二叉树题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。1234567891011121314151617public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;(); if(root &#x3D;&#x3D; null) return list; &#x2F;&#x2F; 根放入队列 queue.offer(root); while (!queue.isEmpty()) &#123; TreeNode node &#x3D; queue.poll(); list.add(node.val); if(node.left !&#x3D; null) queue.offer(node.left); if(node.right !&#x3D; null) queue.offer(node.right); &#125; return list;&#125; 二叉树之二叉树中和为某一值的路径题目描述 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)12345678910111213141516171819202122232425public class Solution &#123; &#x2F;&#x2F;最终路径结果列表 private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F;每一条路径，其实是用线性表模拟的栈结构 private ArrayList&lt;Integer&gt; path &#x3D; new ArrayList&lt;&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root &#x3D;&#x3D; null ) return result; &#x2F;&#x2F;1.入栈 path.add(root.val); &#x2F;&#x2F;2.判断是否叶子节点，且路径和是否满足要求 boolean isLeaf &#x3D; root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null; &#x2F;&#x2F;如果路径值减为0，且当前节点是叶子节点，则满足要求 if((target - root.val) &#x3D;&#x3D; 0 &amp;&amp; isLeaf)&#123; result.add(new ArrayList&lt;Integer&gt;(path));&#x2F;&#x2F;当前路径加入结果列表 &#125; &#x2F;&#x2F;3.左右子树递归。如果有左右子节点继续以上操作，注意：顺序不能变，先递归左子节点，后递归右子节点 if(root.left !&#x3D; null) FindPath(root.left,target - root.val); if(root.right !&#x3D; null) FindPath(root.right,target - root.val); &#x2F;&#x2F;4.出栈，回溯，弹出栈顶元素：深度遍历完成一条路径后，进行回退到父节点的操作 path.remove(path.size() - 1); return result; &#125;&#125; 二叉树之二叉树的深度题目描述 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。1234567891011public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root &#x3D;&#x3D; null) return 0; int nLeft &#x3D; TreeDepth(root.left); &#x2F;&#x2F;左子树的深度 int nRight &#x3D; TreeDepth(root.right);&#x2F;&#x2F;右子树的深度 &#x2F;&#x2F;若无子节点，则返回深度是1 return 1 + Math.max(nLeft,nRight); &#125;&#125; 二叉树之平衡二叉树题目描述 输入一棵二叉树，判断该二叉树是否是平衡二叉树。平衡二叉树概念 每一个节点的左右子树的高度差的绝对值不大于1，或者本身是空树。实现一，从上到下遍历的思路： 123456789101112131415161718192021222324public boolean IsBalanced_Solution(TreeNode pRoot) &#123; if (pRoot &#x3D;&#x3D; null) &#123; return true; &#125; int left &#x3D; TreeDepth(pRoot.left); int right &#x3D; TreeDepth(pRoot.right); int diff &#x3D; left - right; &#x2F;&#x2F;判断高度差 if (diff &gt; 1 || diff &lt; -1) &#123; return false; &#125; &#x2F;&#x2F;由于从上到下的遍历思想，所以左右子节点也要同样的判断，这里就导致了底层的树深会被计算多次，增加额外开销。 return IsBalanced_Solution(pRoot.right) &amp;&amp; IsBalanced_Solution(pRoot.left); &#125; private int TreeDepth(TreeNode pRoot) &#123; if (pRoot &#x3D;&#x3D; null) &#123; return 0; &#125; int left &#x3D; TreeDepth(pRoot.left); int right &#x3D; TreeDepth(pRoot.right); return 1 + Math.max(left,right); &#125; 实现二，剪枝思路，从下到上遍历的思路： 1234567891011121314151617public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; return getDepth(root) !&#x3D; -1; &#125; private int getDepth(TreeNode root) &#123; if (root &#x3D;&#x3D; null) return 0; &#x2F;&#x2F;左子树深度 int left &#x3D; getDepth(root.left); if (left &#x3D;&#x3D; -1) return -1;&#x2F;&#x2F;剪枝 &#x2F;&#x2F;右子树深度 int right &#x3D; getDepth(root.right); if (right &#x3D;&#x3D; -1) return -1;&#x2F;&#x2F;剪枝 &#x2F;&#x2F;左右子树的深度差的绝对值大于1，不是平衡二叉树，直接返回-1； 否则，返回树深 return Math.abs(left - right) &gt; 1 ? -1 : 1 + Math.max(left, right); &#125;&#125; 二叉树之二叉树的下一个结点题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。​ ① 如果节点有右子树，它的下一个节点就是右子树的最左节点，比如a的下一个节点就是a.right.left = f，e的下一个节点就是e.right= i。 ②如果节点没有右子树，且是它的父节点的左子节点，那么下一个节点就是它的父节点，比如 h.next = e。 ③如果节点没有右子树，且是它的父节点的右子节点，那么下一个节点稍微有点复杂，需要往上遍历一直找到是它的父节点的左子节点的节点，比如i.next.next = b，b是左子节点，所以此时，b的父节点就是下一个节点。 123456789101112131415161718192021222324252627282930public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if(pNode &#x3D;&#x3D; null) return null; TreeLinkNode pNext &#x3D; null; &#x2F;&#x2F;1.如果有右子树，求右子树的最左节点 if(pNode.right !&#x3D; null)&#123; pNode &#x3D; pNode.right; while(pNode.left !&#x3D; null)&#123; pNode &#x3D; pNode.left; &#125; pNext &#x3D; pNode; &#125; &#x2F;&#x2F;2.如果没有右子树 else if(pNode.next !&#x3D; null)&#123; TreeLinkNode parent &#x3D; pNode.next;&#x2F;&#x2F;父节点 &#x2F;&#x2F;如果该节点为其父节点的右子节点 while(parent !&#x3D; null &amp;&amp; pNode &#x3D;&#x3D; parent.right)&#123; &#x2F;&#x2F;往上寻找，画图好理解 pNode &#x3D; parent; parent &#x3D; pNode.next; &#125; &#x2F;&#x2F;跳出循环，此时的pNode是它的父节点的左子节点的节点，此时的parent就是下一个节点 pNext &#x3D; parent; &#125; return pNext; &#125;&#125; 二叉树之对称的二叉树题目描述 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。123456789101112131415161718192021222324public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; if(pRoot &#x3D;&#x3D; null) return true; return compareRoot(pRoot.left, pRoot.right); &#125; &#x2F;** ** 递归其实是比较的两个节点的值 * 形参虽然写的是left和right，但不一定表示的是同一个节点的左右子树 *&#x2F; private boolean compareRoot(TreeNode left, TreeNode right) &#123; &#x2F;&#x2F;只有一个根节点 if(left &#x3D;&#x3D; null &amp;&amp; right &#x3D;&#x3D;null) return true; &#x2F;&#x2F;左右子节点不相等:一个为null,另一个不为null if(left &#x3D;&#x3D; null || right &#x3D;&#x3D; null) return false; &#x2F;&#x2F;条件，需要考虑3层 &#x2F;&#x2F;①左右子节点相等 &#x2F;&#x2F;②左子节点的左子节点 &#x3D;&#x3D; 右子节点的右子节点 &#x2F;&#x2F;③左子节点的右子节点 &#x3D;&#x3D; 右子节点的左子节点 return left.val &#x3D;&#x3D; right.val &amp;&amp; compareRoot(left.left,right.right) &amp;&amp; compareRoot(left.right,right.left); &#125;&#125; 二叉树之按之字形顺序打印二叉树题目描述 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。思路 关键点： 用两个栈分别保存奇数层和偶数层的节点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F;final Stack&lt;TreeNode&gt; s1 &#x3D; new Stack&lt;&gt;();&#x2F;&#x2F;奇数层栈 s1.push(pRoot);&#x2F;&#x2F;初始化 Stack&lt;TreeNode&gt; s2 &#x3D; new Stack&lt;&gt;();&#x2F;&#x2F;偶数层栈 int layer &#x3D; 1; &#x2F;&#x2F;记录奇数偶数的标识 while(!s1.isEmpty() || !s2.isEmpty())&#123; &#x2F;&#x2F;保存每层节点数据 ArrayList&lt;Integer&gt; layerList &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F;如果是奇数层 if(layer % 2 !&#x3D; 0)&#123; &#x2F;&#x2F;遍历奇数栈中每一个节点，打印同时将其子节点放入偶数栈中 while(!s1.isEmpty())&#123; TreeNode node &#x3D; s1.pop(); if(node !&#x3D; null)&#123; layerList.add(node.val);&#x2F;&#x2F;打印 &#x2F;&#x2F;将左右子树加入偶数栈 s2.push(node.left); s2.push(node.right); &#125; &#125; &#x2F;&#x2F;当前层放入最终列表中 if(!layerList.isEmpty())&#123; result.add(layerList); layerList &#x3D; new ArrayList&lt;Integer&gt;(); &#125; layer++;&#x2F;&#x2F;处理完一层后，改变奇偶标识符 &#125; &#x2F;&#x2F;如果是偶数层 else&#123; &#x2F;&#x2F;遍历偶数栈中每一个节点，打印同时将其子节点放入奇数栈中 while(!s2.isEmpty())&#123; TreeNode node &#x3D; s2.pop(); if(node !&#x3D; null)&#123; layerList.add(node.val);&#x2F;&#x2F;打印 &#x2F;&#x2F;将左右子树加入奇数栈 &#x2F;&#x2F;由于奇数栈打印是从左往右，所以奇数栈入栈要从右往左 s1.push(node.right); s1.push(node.left); &#125; &#125; &#x2F;&#x2F;当前层放入最终列表中 if(!layerList.isEmpty())&#123; result.add(layerList); layerList &#x3D; new ArrayList&lt;Integer&gt;(); &#125; layer++;&#x2F;&#x2F;处理完一层后，改变奇偶标识符 &#125; &#125; return result; &#125;&#125; 二叉树之序列化二叉树题目描述 请实现两个函数，分别用来序列化和反序列化二叉树思路 这题其实挺开放的，没规定具体的序列化规则，我们可以使用先序遍历的方式， ① 序列化规则：#表示空，节点之前用，分隔。 ② 反序列化规则：相当于重建二叉树，可以参考之前的博客。1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int index &#x3D; -1; String Serialize(TreeNode root) &#123; StringBuffer sb &#x3D; new StringBuffer(); if(root &#x3D;&#x3D; null)&#123; sb.append(&quot;#,&quot;); return sb.toString(); &#125; &#x2F;&#x2F;先序遍历 sb.append(root.val+&quot;,&quot;);&#x2F;&#x2F;先根 sb.append(Serialize(root.left));&#x2F;&#x2F;后左 sb.append(Serialize(root.right));&#x2F;&#x2F;最后右 return sb.toString(); &#125; TreeNode Deserialize(String str) &#123; index++;&#x2F;&#x2F;计数指针，为什么起作用？ &#x2F;&#x2F;因为左树构造完了才会构造右子树，跟序列化时顺序一致，所以递归时顺序才能对上 if(index &gt;&#x3D; str.length())&#123; return null; &#125; String[] strr &#x3D; str.split(&quot;,&quot;); TreeNode node &#x3D; null; &#x2F;&#x2F;递归终止条件，碰到#号 if(!strr[index].equals(&quot;#&quot;))&#123; &#x2F;&#x2F;按照顺序：根、左、右构造二叉树 node &#x3D; new TreeNode(Integer.valueOf(strr[index])); node.left &#x3D; Deserialize(str); node.right &#x3D; Deserialize(str); &#125; return node; &#125;&#125; 二叉搜索树之二叉搜索树的后序遍历序列题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; return bst(sequence,0,sequence.length-1); &#125; public boolean bst(int [] sequence,int begin,int end) &#123; if(sequence &#x3D;&#x3D; null || sequence.length &#x3D;&#x3D; 0) return false; &#x2F;&#x2F;1.确定根节点 int root &#x3D; sequence[end]; int i &#x3D; begin;&#x2F;&#x2F;左子树起始索引 &#x2F;&#x2F;2.确定左右子树分解点，通过遍历左子树 for(;i &lt; end ; i++)&#123; &#x2F;&#x2F;当找到第一个大于root的数值时，即找到了左右子树的分界点 if(sequence[i] &gt; root) break; &#125; int j &#x3D; i;&#x2F;&#x2F;右子树起始索引 &#x2F;&#x2F;3.判断右子树符不符合二叉搜索树的特性 for(; j &lt; end; j++)&#123; &#x2F;&#x2F;右子树中有小于root的数值，return fasle if(sequence[j] &lt; root) return false; &#125; &#x2F;&#x2F;4.左右子树递归，判断左子树是不是二叉搜索树 boolean left &#x3D; true; if(i &gt; begin)&#123; left &#x3D; bst(sequence,begin, i-1);&#x2F;&#x2F;i-1 为左子树的倒数第一个索引 &#125; &#x2F;&#x2F;递归判断右子树是不是二叉搜索树 boolean right &#x3D; true; if(i &lt; end -1 )&#123; right &#x3D; bst(sequence,i, end - 1);&#x2F;&#x2F;end - 1为数组倒数第2个节点:右子树的倒数第一个索引 &#125; return left &amp;&amp; right; &#125;&#125; 二叉搜索树之二叉搜索树与双向链表题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; private TreeNode tail &#x3D; null;&#x2F;&#x2F;链表尾节点 private TreeNode head &#x3D; null;&#x2F;&#x2F;链表头结点 public TreeNode Convert(TreeNode pRootOfTree) &#123; if(pRootOfTree &#x3D;&#x3D; null ) return null; ConvertNode(pRootOfTree);&#x2F;&#x2F;开始转换 return head; &#125; &#x2F;** * 二叉树转双向链表核心方法 * @param root * @param pLastNodeInList *&#x2F; public void ConvertNode(TreeNode pRootOfTree) &#123; if(pRootOfTree &#x3D;&#x3D; null) return;&#x2F;&#x2F;校验 &#x2F;&#x2F;递归左子树 ConvertNode(pRootOfTree.left); &#x2F;&#x2F;第一次执行下面这块时，是在最左子树的最左叶子节点,此时的pRootOfTree&#x3D;4就是叶子节点本身 &#x2F;&#x2F;初始化链表的头节点和尾节点（每次递归，链表新增加节点时，都需要改动tail） if(head &#x3D;&#x3D; null)&#123; head &#x3D; pRootOfTree;&#x2F;&#x2F;head &#x3D;4 tail &#x3D; pRootOfTree;&#x2F;&#x2F;tail &#x3D; 4 &#125; &#x2F;&#x2F;通过递归退回到父节点，此时的pRootOfTree&#x3D;6就是父节点本身 else&#123; &#x2F;&#x2F;实现双向链表,比如4.right&#x3D;6，6.left&#x3D;4 tail.right &#x3D; pRootOfTree; pRootOfTree.left &#x3D; tail; &#x2F;&#x2F;此时链表新加了节点pRootOfTree&#x3D;6，所以tail需要改成6 tail &#x3D; pRootOfTree; &#125; &#x2F;&#x2F;递归右子树 ConvertNode(pRootOfTree.right); &#125;&#125; 二叉搜索树之二叉搜索树的第k个结点题目描述 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。1234567891011121314151617181920212223242526public class Solution &#123; private int index &#x3D; 0;&#x2F;&#x2F;计数器 TreeNode KthNode(TreeNode pRoot, int k) &#123; if(pRoot &#x3D;&#x3D; null || k &lt; 0) return null; return KthNodeCore(pRoot, k); &#125; TreeNode KthNodeCore(TreeNode pRoot, int k)&#123; if(pRoot &#x3D;&#x3D; null) return null; &#x2F;&#x2F;左子树中查找 TreeNode node &#x3D; KthNodeCore(pRoot.left,k); if(node !&#x3D; null) return node; &#x2F;&#x2F;根节点 index++; if(index &#x3D;&#x3D; k) return pRoot; &#x2F;&#x2F;右子树中查找 node &#x3D; KthNodeCore(pRoot.right,k); if(node !&#x3D; null) return node; return null; &#125;&#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"字符串","slug":"字符串","date":"2020-04-03T13:49:49.000Z","updated":"2020-04-07T13:20:22.185Z","comments":true,"path":"2020/04/03/字符串/","link":"","permalink":"http://yoursite.com/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"字符串之替换空格题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。","text":"字符串之替换空格题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。12345678910111213141516public static void main(String[] args) &#123; StringBuffer str &#x3D; new StringBuffer(&quot;hello &quot;); System.out.println(replaceBlank(str)); &#125; static String replaceBlank(StringBuffer str) &#123; if(str &#x3D;&#x3D; null) return null; for(int i &#x3D; 0; i &lt; str.length(); i++)&#123; if(str.charAt(i) &#x3D;&#x3D; &#39; &#39;)&#123; str.replace(i, i+1, &quot;%20&quot;); &#125; &#125; return str.toString(); &#125; 字符串的排列题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。把字符串分为两部分：一部分是字符串的第一个字符，另一部分是第一个字符以后的所有字符。 第一步是求所有可能出现在第一个位置的字符，即把第一个字符和后面所有字符交换。（for循环、交换操作）第二步是固定住第一个字符，求后面所有字符的排列。（递归）而“求后面所有字符的排列”即可按照上面的思路递归进行。 12345678910111213141516171819202122232425262728private static void permutationCore(char[] str, int begin, List&lt;String&gt; res) &#123; &#x2F;&#x2F;终止条件 if(begin &#x3D;&#x3D; str.length -1)&#123; res.add(String.valueOf(str));&#x2F;&#x2F;这个操作就是【回溯】，由下到上依次把结果保存到res中 &#125; else&#123; for(int i &#x3D; begin ; i &lt; str.length; i++)&#123; &#x2F;&#x2F;相同字符处理 if(i!&#x3D; begin &amp;&amp; str[begin] &#x3D;&#x3D; str[i])&#123; continue; &#125; &#x2F;&#x2F;将第一个字符begin与后面每一个字符交换位置 swap(str,begin,i); &#x2F;&#x2F;对每一个交换后的字符集，固定第一个字符，从第二个字符开始继续执行以上操作 permutationCore(str, begin+1, res); &#x2F;&#x2F;还原到交换前的状态，否则影响后续循环，也就是说第一步第一个字符与后面字符交换的前提是str的顺序不能变 swap(str,begin,i); &#125; &#125; &#125; private static void swap(char[] str, int begin, int i) &#123; char temp &#x3D; str[begin]; str[begin] &#x3D; str[i]; str[i] &#x3D; temp; &#125; 字符串之第一次只出现一次的字符题目描述 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.把字母的ASCII码值当成索引建立哈希表（通过ASCII码映射到内存中唯一存储位置，存储记录的数组叫散列表,即哈希表(HashTable), 哈希算法为ASCII码） 123456789101112131415161718192021static int firstNotRepeatingChar(String str)&#123; &#x2F;&#x2F;校验 if(str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D; 0) return -1; char [] arr &#x3D; str.toCharArray(); int size &#x3D; &#39;z&#39;;&#x2F;&#x2F;字母的ASCII码最大值 int [] hashTable &#x3D; new int [size+1];&#x2F;&#x2F;因为索引是0 ~ size -1 &#x3D;&gt; 0 ~ 121 ，所以如果输入z为122，下标越界 &#x2F;&#x2F;构造表，用ASCII码数组记录每个字母出现次数 for(int i &#x3D; 0 ; i &lt; arr.length; i++)&#123; hashTable[(int)arr[i]]++; &#125; &#x2F;&#x2F;查表，返回当前索引值 for(int i &#x3D; 0 ; i &lt; arr.length; i++)&#123; if(hashTable[(int)arr[i]] &#x3D;&#x3D; 1) return i; &#125; return -1; &#125; 字符串之左旋转字符串题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 123456static String leftRotateString(String str,int n) &#123; &#x2F;&#x2F;校验 if(str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D;0 || n &lt;&#x3D; 0) return str; return str.substring(n, str.length()) + str.substring(0, n); &#125; 123456789101112131415&#x2F;&#x2F;左移一次class Solution &#123; public boolean rotateString(String A, String B) &#123; if(A.isEmpty()&amp;&amp;B.isEmpty()) return true; for(int i&#x3D;0;i&lt;A.length();i++)&#123; char[] array &#x3D; A.toCharArray(); char C &#x3D; array[0]; for(int n&#x3D;0;n&lt;A.length()-1;n++) array[n] &#x3D; array[n+1]; array[A.length()-1] &#x3D; C; A &#x3D; String.valueOf(array); &#125; return false; &#125; 字符串之翻转单词顺序列牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 12345678910111213141516static String reverseSentence(String str) &#123; &#x2F;&#x2F;校验 if(str &#x3D;&#x3D; null || str.length() &#x3D;&#x3D;0) return str; String [] s &#x3D; str.split(&quot; &quot;); if(s.length &gt; 0)&#123; String reStr &#x3D; &quot;&quot;; for(int i &#x3D; s.length - 1; i &gt;&#x3D; 0;i--)&#123; reStr+&#x3D;s[i]+&quot; &quot;; &#125; return reStr.substring(0, reStr.length() - 1); &#125; return str; &#125; 字符串之把字符串转换成整数题目描述 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 输入描述: 输入一个字符串,包括数字字母符号,可以为空 输出描述: 如果是合法的数值表达则返回该数字，否则返回0 注意点如下： ① 参数校验，空字符串和是否合法数字(即小于等于’9’，大于等于’0’；) ②符号位处理。 ③ int类型为4字节32位，判断溢出。 ④ 使用错误标识枚举。 还需要注意：char转int的处理，直接强转会转为ASCII码。123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int StrToInt(String str) &#123; if(str&#x3D;&#x3D;null||str.trim().equals(&quot;&quot;))&#123; return 0; &#125; char[] cc &#x3D; str.toCharArray(); int i,sum&#x3D;0,flag&#x3D;1; if(cc[0]&#x3D;&#x3D;&#39;-&#39;)&#123; i&#x3D;1; flag &#x3D; -1; &#125; else if(cc[0]&#x3D;&#x3D;&#39;+&#39;)&#123; i&#x3D;1; flag &#x3D; 1; &#125; else&#123; i&#x3D;0; &#125; while(i&lt;cc.length)&#123; if(isNumber(cc[i]))&#123; sum &#x3D; sum * 10 + (cc[i] - &#39;0&#39;); &#125; else&#123; return 0; &#125; i++; &#125; return sum * flag; &#125; public boolean isNumber(char c)&#123; if(c&#x3D;&#x3D;&#39;0&#39;||c&#x3D;&#x3D;&#39;1&#39;||c&#x3D;&#x3D;&#39;2&#39;||c&#x3D;&#x3D;&#39;3&#39;||c&#x3D;&#x3D;&#39;4&#39;||c&#x3D;&#x3D;&#39;5&#39;||c&#x3D;&#x3D;&#39;6&#39;||c&#x3D;&#x3D;&#39;7&#39;||c&#x3D;&#x3D;&#39;8&#39;||c&#x3D;&#x3D;&#39;9&#39;)&#123; return true; &#125; return false; &#125;&#125; 字符串之表示数值的字符串题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 例如，字符串”+100”,“5e2”,”-123”,“3.1416”和”-1E-16”都表示数值，但是”12e”,“1a3.14”,“1.2.3”,”±5”和”12e+4.3”都不是。 思路：首先，搞清楚组成数字的4个部分： ① 数字本身 0-9 ② 数字符号 + 或 - ③ 小数点 . ④ e或E 然后，判断每一个数字位.判断时需要考虑3种情况： ① 若是正负号，必须出现在首位或e的后一位 ② 若是e，之前必须出现过数字且没出现过e ③ 若是.，之前必须没出现过.和e 1234567891011121314151617181920212223242526272829303132333435363738public static boolean isNumeric2(char[] s) &#123; if (s &#x3D;&#x3D; null || s.length &#x3D;&#x3D; 0) return false; &#x2F;&#x2F; 记录是否出现过数字 boolean numberSeen &#x3D; false; &#x2F;&#x2F; 是否出现过小数点 boolean pointSeen &#x3D; false; &#x2F;&#x2F; 是否出现过指数标志e boolean eSeen &#x3D; false; &#x2F;&#x2F; e后是否出现过数字 boolean numberAfterE &#x3D; false; for (int i &#x3D; 0; i &lt; s.length; i++) &#123; char c &#x3D; s[i]; &#x2F;&#x2F; 如果是数字 if (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) &#123; numberSeen &#x3D; true; numberAfterE &#x3D; true;&#x2F;&#x2F;对于输入为纯数字的情况，要先设为true &#x2F;&#x2F; 如果是小数点 &#125; else if (c &#x3D;&#x3D; &#39;.&#39;) &#123; if (pointSeen || eSeen) return false; pointSeen &#x3D; true; &#x2F;&#x2F; 如果是e || E，必须没有出现过且出现过数字 &#125; else if (c &#x3D;&#x3D; &#39;e&#39; || c &#x3D;&#x3D; &#39;E&#39;) &#123; if (eSeen || !numberSeen) return false; eSeen &#x3D; true; numberAfterE &#x3D; false; &#x2F;&#x2F; 如果出现正负号，必须是首位，或者前一位是e || E &#125; else if (c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39;) &#123; if (i !&#x3D; 0 &amp;&amp; s[i - 1] !&#x3D; &#39;e&#39; &amp;&amp; s[i - 1] !&#x3D; &#39;E&#39;) return false; &#125; else return false; &#125; return numberSeen &amp;&amp; numberAfterE;&#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"数组","slug":"数组","date":"2020-04-03T13:49:49.000Z","updated":"2020-04-07T13:18:47.024Z","comments":true,"path":"2020/04/03/数组/","link":"","permalink":"http://yoursite.com/2020/04/03/%E6%95%B0%E7%BB%84/","excerpt":"数组二维数组查找【找规律】题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。","text":"数组二维数组查找【找规律】题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。12345678910111213141516171819202122public class Solution&#123; public boolean find(int target,int[][] array)&#123; if(array.length&lt;0 ) return false; &#x2F;&#x2F;参数校验 &#x2F;&#x2F; 从二维数组的最右上角开始查找。 int row &#x3D; 0; &#x2F;&#x2F;当前行 int col &#x3D; array[0].length -1 ; &#x2F;&#x2F;当前列 while(row &gt; array.length &amp;&amp; col &gt;&#x3D;0)&#123; &#x2F;&#x2F;如果最右上角的数字小于target，直接干掉当前行，row++ if(array[row][col]&lt; target)&#123; row ++; &#125; &#x2F;&#x2F;如果最右上角的数字大于target，直接干掉当前列，col-- if(array[row][col]&gt; target)&#123; col --; &#125; else&#123; return ture; &#125; &#125; return false; &#125;&#125; 数组之旋转数组的最小数字【特殊二分查找】题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; int len&#x3D;array.length; int left&#x3D;0; int right&#x3D;len-1; while(start &lt; end)&#123; &#x2F;&#x2F;左右指针相邻 if(end - start &#x3D;&#x3D; 1)&#123; mid &#x3D; end; break; &#125; mid &#x3D; (start+end) &gt;&gt; 1; &#x2F;&#x2F;特殊情况 11011 if(array[mid] &#x3D;&#x3D; array[start] &amp;&amp; array[start] &#x3D;&#x3D; array[end])&#123; return findInOrder(array,start,end); &#125; &#x2F;&#x2F;mid在左边递增数组中，最小值在右边，移动左指针 if(array[mid] &gt;&#x3D; array[start])&#123; start &#x3D; mid ; &#125;else&#123;&#x2F;&#x2F;mid 在右边递增数组中，最小值在左边，移动右指针 end &#x3D; mid ; &#125; &#125; return array[mid]; &#125; &#x2F;&#x2F;顺序查找 public int findInOrder(int [] array,int start,int end)&#123; int minNum &#x3D; array[start]; for(int i&#x3D; start+1;i&lt;end;i++)&#123; if(array[i] &lt; minNum)&#123; minNum &#x3D; array[i]; &#125; &#125; return minNum; &#125;&#125; 数组之调整数组顺序使奇数位于偶数前面【特殊快速排序】题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。12345678910111213141516171819202122public class Solution &#123; public boolean reOrderArray(int [] array) &#123; &#x2F;&#x2F;校验入参 if(array.length &lt; 0 )&#123; return false; &#125; int a&#x3D;0,b&#x3D;array.length-1,temp; while(a&lt;b)&#123; if(arr[a]%2&#x3D;&#x3D;1) a++; if(arr[b]%2&#x3D;&#x3D;0) b--; if((arr[a]%2&#x3D;&#x3D;0)&amp;&amp;(arr[b]%2&#x3D;&#x3D;1)) &#123; temp&#x3D;arr[a]; arr[a]&#x3D;arr[b]; arr[b]&#x3D;temp; a++; b--; &#125; &#125; return ture; &#125;&#125; 数组之数组中出现次数超过一半的数字题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。1.快速排序 在随机快速排序算法中，我们先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小数字都排在它的左边，比选中的数字大的数字都排在它的右边。如果这个选中的数字的下标刚好是n/2，那么这个数字就是数组的中位数。如果它的下标大于n/2，那么中位数应该位于它的左边，我们可以接着在它的左边部分的数组中查找。如果它的下标小于n/2，那么中位数应该位于它的右边，我们可以接着在它的右边部分的数组中查找。 1234567891011121314151617181920212223242526272829303132333435363738int moreThanHalfNum(int[] array, int length)&#123; if(if(array &#x3D;&#x3D; null &amp;&amp; length &lt;&#x3D; 0)&#123;)&#123; return -1; &#125; int middle &#x3D; length &gt;&gt; 1; int start &#x3D; 0; int end &#x3D; length - 1; int index &#x3D; Partition(array, length, start, end); &#x2F;&#x2F; 寻找中位数 while(index !&#x3D; middle)&#123; &#x2F;&#x2F; 如果得到 index 大于中间值，则往前半部分查找 if(index &gt; middle)&#123; end &#x3D; index - 1; index &#x3D; Partition(array, length, start, end); &#125;else&#123; start &#x3D; index + 1; index &#x3D; Partition(array, length, start, end); &#125; &#125; int result &#x3D; array[middle]; if(!CheckMoreThanHalf(array, length, result))&#123; return -1; &#125; return result;&#125;boolean CheckMoreThanHalf(int[] array, int length, int number)&#123; int times &#x3D; 0; for (int i &#x3D; 0; i &lt; length; i++) &#123; if(array[i] &#x3D; number)&#123; times++; &#125; &#125; boolean isMoreThanHalf &#x3D; true; if(times * 2 &lt;&#x3D; length)&#123; isMoreThanHalf &#x3D; false; &#125; return isMoreThanHalf;&#125; 2.数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。 当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1； 如果下一个数字和我们之前保存的数字不同，则次数减1。 如果次数为零，我们需要保存下一个数字，并把次数设为1。 12345678910111213141516171819202122232425262728 public Integer moreThanHalfNum(int[] array) &#123; if (array &#x3D;&#x3D; null) return null; Integer number &#x3D; null; int count &#x3D; 0; Integer resultInteger &#x3D; null; for (int i &#x3D; 0; i &lt; array.length; i++) &#123; if (number &#x3D;&#x3D; null) &#123; number &#x3D; array[i]; count++; &#125; else &#123; if (array[i] !&#x3D; number) if (count &#x3D;&#x3D; 0) &#123; number &#x3D; array[i]; count &#x3D; 1; &#125; else count--; else count++; &#125; if (count &#x3D;&#x3D; 1) resultInteger &#x3D; number; &#125; if (checkMoreThanHalf(array, resultInteger)) return resultInteger; else return null;&#125; 数组之连续子数组的最大和【动态规划】题目描述 给一个整型数组，有正有负，数组中的一个或连续多个组成子序列，返回所有连续子序列中和的最大值。例如:{6,-3,-2,7,-15,1,2,2},连续子序列和的最大值为8。 只考虑第一个元素，则最大子段和为其本身 DP[0] = nums[0] 考虑前两个元素，最大子段和为 nums[0],num[1]以及 nums[0] + num[1] 中最大值 设为DP[1] 考虑前三个元素，如何求其最大子段和？还是分为两种情况讨论，第三个元素在最后的字串内吗？ 若第三个元素也包含在最后的字串内，则DP[2] = Max(DP[1]+nums[2] , nums[2]) 初始状态 dp[0] = nums[0] dp[1] = max(dp[0]+nums[1] , nums[1]) 状态转移方程： 12345678910111213141516public class lc53_MaximumSubarray &#123; public int maxSubArray(int[] nums) &#123; int len &#x3D; nums.length; if(len &#x3D;&#x3D; 0) return 0; int [] dp &#x3D; new int[len]; dp[0] &#x3D; nums[0]; int max &#x3D; dp[0]; for (int i &#x3D; 1; i&lt;len;i++)&#123; dp[i] &#x3D; (dp[i-1]+nums[i] &gt; nums[i]) ? dp[i-1]+nums[i] : nums[i]; if (dp[i]&gt;max) max &#x3D; dp[i]; &#125; return max; &#125;&#125; 数组之把数组排成最小的数 排序规则：输入a,b ① 若ab &gt; ba ，因为ba小，所以b应该排在a前面，即a &gt; b; ② 若ab &lt; ba ，则a &lt; b; ③ 若ab = ba ，则a = b;public class RuleSort { static String PrintMinNumber(int [] numbers) { if(numbers.length == 0 ){ return &quot;&quot;; } //1.利用java8 stream将 int数组转为Integer数组 Integer [] nums = IntStream.of(numbers).parallel().boxed() .collect(Collectors.toList()).toArray(new Integer[numbers.length]); //2.根据新规则对原数组进行排序 Arrays.sort( nums, new Comparator&lt;Integer&gt;(){ @Override public int compare(Integer o1, Integer o2) { String A = String.valueOf(o1) + String.valueOf(o2); String B = String.valueOf(o2) + String.valueOf(o1); return A.compareTo(B); } }); //3.将排序后的数组拼接输出即可 String re = Arrays.stream(nums).parallel().map(n-&gt; n.toString()).collect(Collectors.joining(&quot;&quot;)); return re; }数组之数组中的逆序对【归并规划】题目描述 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007public int SplitAndMerge(int [] array, int left, int right, int [] temp) { //校验 if(array == null || array.length == 0 ) return 0; //终止条件 if(left &lt; right){ //1.切分过程 int mid = (left + right) &gt;&gt; 1; //切分点 int leftCount = SplitAndMerge(array, left, mid, temp)%1000000007; int rightCount = SplitAndMerge(array, mid+1, right, temp)%1000000007; //2.合并过程 int count = 0;//逆序对的计数 int i = left; //左子序列的指针 int j = mid +1;//右子序列的指针 int t = 0 ; //临时数组的指针，空间换时间 while(i &lt;= mid &amp;&amp; j &lt;= right){ if(array[i] &lt;= array[j]){ temp[t++] = array[i++]; } else{ temp[t++] = array[j++]; //★核心理解：归并排序中2个子序列是升序从小到大进行比较的 //若array[i] &gt; array[j]，则array[i] ~ array[mid]都会大于arr[j]，所以都属于逆序对 count += mid - i +1 ; if(count &gt;= 1000000007){ count = count % 1000000007; } } } while(i &lt;= mid){ temp[t++] = array[i++]; } while(j &lt;= right){ temp[t++] = array[j++]; } t=0; //将temp数组copy回原数组 while(left &lt;= right){ array[left++] = temp[t++]; } return (leftCount + rightCount + count)%1000000007; } return 0; }数字在排序数组中出现的次数【二分查找】一搬情况下，排序数组中的查找都可以通过二分查找来解决。 ① 通过二分查找查找k,分别找到第一次出现的位置和最后一次出现的索引位置。 ② 通过k出现的第一和最后的位置直接计算出现次数即可，last - first +1。 ③ 二分值mid的三种情况：​ mid &gt; k ,k出现在左子树，只在左子树中查找​ mid &lt; k ,k出现在右子树，只在右子树中查找​ mid = k, 判断k是不是一个k或最后一个k​ 若k的前一个元素还是等于k，则在左子树中继续二分查找​ 同理，k的后一个元素还是等于k，则在右子树中继续二分查找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private static int GetNumberOfK(int [] array, int k) &#123; if(array &#x3D;&#x3D; null &amp;&amp; array.length &#x3D;&#x3D; 0) return -1; int first &#x3D; getFirstK(array, 0, array.length-1, k); int last &#x3D; getLastK(array, 0, array.length-1, k); if(first &gt; -1 &amp;&amp; last &gt; -1)&#123; return last - first + 1; &#125; return 0;&#125; 查找k最后一次出现的位置 static int getFirstK(int [] arr,int left ,int right,int k)&#123; if(arr &#x3D;&#x3D; null &amp;&amp; arr.length &#x3D;&#x3D; 0)&#123; return -1; &#125; &#x2F;&#x2F;终止条件 while(left &lt;&#x3D; right)&#123; int midIndex &#x3D; (left + right) &gt;&gt; 1; if(arr[midIndex] &gt; k)&#123; right &#x3D; midIndex - 1; &#125; else if(arr[midIndex] &lt; k)&#123; left &#x3D; midIndex + 1; &#125; &#x2F;&#x2F;如果mid等于k，且前一个元素不等于k，说明k是第一次出现，返回索引 else&#123; &#x2F;&#x2F; midIndex &gt; 0 防止 arr[midIndex-1] 数组下标越界 if((midIndex &gt; 0 &amp;&amp; arr[midIndex -1] !&#x3D; k) || midIndex &#x3D;&#x3D; 0)&#123; return midIndex; &#125; else&#123;&#x2F;&#x2F;如果前一个元素也跟k相等，则在前面子序列中二分查找 right &#x3D; midIndex - 1; &#125; &#125; &#125; return -1; &#125; 查找k最后一次出现的位置 static int getLastK(int [] arr,int left ,int right,int k)&#123; if(arr &#x3D;&#x3D; null &amp;&amp; arr.length &#x3D;&#x3D; 0)&#123; return -1; &#125; &#x2F;&#x2F;终止条件 while(left &lt;&#x3D; right)&#123; int midIndex &#x3D; (left + right) &gt;&gt; 1; if(arr[midIndex] &gt; k)&#123; right &#x3D; midIndex - 1; &#125; else if(arr[midIndex] &lt; k)&#123; left &#x3D; midIndex + 1; &#125; &#x2F;&#x2F;如果mid等于k，且后一个元素不等于k，说明k是最后一次出现，返回索引 else&#123; &#x2F;&#x2F; midIndex &lt; arr.length -1 防止 arr[midIndex+1] 数组下标越界 if((midIndex &lt; arr.length -1 &amp;&amp; arr[midIndex +1] !&#x3D; k) || midIndex &#x3D;&#x3D; arr.length -1)&#123; return midIndex; &#125; else&#123;&#x2F;&#x2F;如果后一个元素也跟k相等，则在后面子序列中二分查找 left &#x3D; midIndex + 1; &#125; &#125; &#125; return -1; &#125; 数组之数组中只出现一次的数字【位运算，异或】题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 ① 异或操作满足交换结合律，比如A ^ B ^ A = B ^ (A ^A) = B ^ 0 = B。所以，数组中数字两两异或，若其中有2个单次出现的数字，最后得到的结果就是这2个单次数字的异或结果，其他出现2次的数字都异或抵消掉了。 ② 通过①的分析，假设数组中只有一个单次的数字，那么异或后的结果就是这个数，所以，考虑把原数组分开，通过什么分开呢？原数组异或结果位数为1的索引值，区分开2个单次的数，最后分别求2个子数组异或的结果即可。 public class NumXOR { public static void main(String[] args) { int [] array = {2,4,3,6,3,2,5,5}; int[] num1 = new int[array.length]; int[] num2 = new int[array.length]; findNumsAppearOnce(array, num1, num2); System.out.println(num1[0] + &quot; &quot; + num2[0]); } /** * * @param array * @param num1 存放返回结果 * @param num2 */ static void findNumsAppearOnce(int [] array,int num1[] , int num2[]){ if(array == null || array.length == 0){ num1[0] = -1; num2[0] = -1; } //1. 求原数组两两异或结果 int bitResult = 0; for(int i =0 ; i &lt; array.length; i++){ bitResult ^= array[i]; } //2. 找到倒数第一个1的位置 int index = findFirst1(bitResult); //3. 根据index位上是不是1切分原数组，并将子数组两两异或。 for(int i =0 ; i &lt; array.length; i++){ if(isBit1(array[i],index)){ num1[0] ^= array[i]; } else{ num2[0] ^= array[i]; } } //4. 最终得到单次出现数字num1[0] num2[0] } /** * 找到原数组异或结果的倒数第一个1的位置 * @param bitResult * @return */ static int findFirst1(int bitResult){ int index = 0; while((bitResult &amp; 1) == 0){ bitResult &gt;&gt;= 1; index++; } return index; } /** * 判断数字第index位置上是不是1 * @param target * @param index * @return */ static boolean isBit1(int target, int index){ return ((target &gt;&gt; index) &amp; 1) == 1; } }数组之数组中重复的数字 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 （1）hash数组的下标，就可以用来记录numbers的元素，0-n-1。 （2）hash数组的下标对应的值，就可以用来记录numbers的元素出现的次数。 1234567891011121314151617181920212223public boolean duplicate(int numbers[], int length, int[] duplication) &#123; if (numbers &#x3D;&#x3D; null) &#123; return false; &#125; for (int i &#x3D; 0; i &lt; length; i++) &#123; if (numbers[i] &lt; 0 || numbers[i] &gt; length - 1) &#123; return false; &#125; &#125; &#x2F;&#x2F; 利用数组的数字不超过n-1的特性，创建一个hash数组 &#x2F;&#x2F; hash数组的下标记为0-n-1，下标对应的值，则是出现的次数 int[] hash &#x3D; new int[length]; for (int i &#x3D; 0; i &lt; length; i++) &#123; hash[numbers[i]]++; &#125; for (int i &#x3D; 0; i &lt; length; i++) &#123; if (hash[i] &gt; 1) &#123; duplication[0] &#x3D; i; return true; &#125; &#125; return false;&#125; 数组之构建乘积数组题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。123456789101112131415161718static int[] multiply(int[] A) &#123; int length &#x3D; A.length; int[] B &#x3D; new int[length]; if(length !&#x3D; 0 )&#123; B[0] &#x3D; 1; &#x2F;&#x2F;计算下三角连乘，从正数第二行开始 i&#x3D;1 for(int i &#x3D; 1; i &lt;&#x3D; length -1 ; i++)&#123; B[i] &#x3D; B[i-1] * A[i-1]; &#x2F;&#x2F;此时的B就是分析中的C &#125; int tempD &#x3D; 1;&#x2F;&#x2F;length -1 位置上的值 &#x2F;&#x2F;计算上三角, 从倒数第二行开始 j&#x3D;length-2 for(int i &#x3D; length-2; i &gt;&#x3D; 0; i--)&#123; tempD &#x3D; tempD * A[i+1]; &#x2F;&#x2F;D &#x3D; D[i+1] * A[i+1], 当i&#x3D;length-2时，D[i+1] &#x3D; length -1 位置上的值 tempD &#x3D; 1 B[i] &#x3D; B[i] * tempD; &#x2F;&#x2F;B &#x3D; C * D &#125; &#125; return B; &#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"链表","slug":"链表","date":"2020-04-03T13:49:49.000Z","updated":"2020-04-07T13:18:40.451Z","comments":true,"path":"2020/04/03/链表/","link":"","permalink":"http://yoursite.com/2020/04/03/%E9%93%BE%E8%A1%A8/","excerpt":"链表链表之从尾到头打印链表题目描述 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。","text":"链表链表之从尾到头打印链表题目描述 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。12345678910public class Solution &#123; ArrayList&lt;Integer&gt; arrayList&#x3D;new ArrayList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if(listNode!&#x3D;null)&#123; this.printListFromTailToHead(listNode.next); arrayList.add(listNode.val); &#125; return arrayList; &#125;&#125; 链表之链表中倒数第k个结点题目描述 输入一个链表，输出该链表中倒数第k个结点。123456789101112131415161718192021222324252627public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; if(head &#x3D;&#x3D; null || k &#x3D;&#x3D; 0)&#123; return null; &#125; ListNode p1 &#x3D; head; ListNode p2 &#x3D; head; &#x2F;&#x2F;p2先走k-1步 for(int i &#x3D; 0 ; i &lt; k-1;i++)&#123; if(p2.next!&#x3D;null)&#123; p2 &#x3D; p2.next; &#125;else&#123; return null; &#125; &#125; &#x2F;&#x2F;p1 p2同时走，直到p2达到tail while(p2.next!&#x3D;null)&#123; p1 &#x3D; p1.next; p2 &#x3D; p2.next; &#125; &#x2F;&#x2F;返回p1，即为倒数第k个节点 return p1; &#125;&#125; 链表之反转链表题目描述 输入一个链表，反转链表后，输出新链表的表头。思路 定义2个指针前向pre和当前cur指针。反转链表就要改变指针，改变指针就意味着丢失next节点，所以先保存next节点(定义临时变量nextTemp保存cur.next)，然后改变指针方向，通过交换赋值移动指针pre和cur，继续前面的操作，直到cur.next为null时，此时cur为新链表头。 12345678910111213141516171819public void iterationInvertLinkedList() &#123; &#x2F;&#x2F; 步骤 1 Node pre &#x3D; head; Node cur &#x3D; pre.getNext(); pre.setNext(null); &#x2F;&#x2F; pre 是头结点，避免翻转链表后形成环 &#x2F;&#x2F; 步骤 2 while (cur !&#x3D; null) &#123; &#x2F;** * 务必注意!!!：在 cur 指向 pre 之前一定要先保留 cur 的后继结点，不然如果 cur 先指向 pre，之后就再也找不到后继结点了 *&#x2F; Node next &#x3D; cur.getNext(); cur.setNext(pre); pre &#x3D; cur; cur &#x3D; next; &#125; &#x2F;&#x2F; 此时 pre 指向的是原链表的尾结点，翻转后即为链表 head 的后继结点 head.next &#x3D; pre;&#125; 链表之合并两个排序的链表题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。123456789101112131415161718192021222324public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; &#x2F;&#x2F;判空 if(list1 &#x3D;&#x3D; null)&#123; return list2; &#125;else if(list2 &#x3D;&#x3D; null)&#123; return list1; &#125; ListNode mergeNode &#x3D; null; if(list1.val &lt; list2.val)&#123; mergeNode &#x3D; list1; &#x2F;&#x2F;最小节点的next指向剩余节点中最小的节点 mergeNode.next &#x3D; Merge(list1.next,list2);&#x2F;&#x2F;返回较小节点 &#125; else&#123; mergeNode &#x3D; list2; &#x2F;&#x2F;最小节点的next指向剩余节点中最小的节点 mergeNode.next &#x3D; Merge(list1,list2.next);&#x2F;&#x2F;返回较小节点 &#125; &#x2F;&#x2F;返回较小节点 return mergeNode; &#125;&#125; 链表之复杂链表的复制题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; cloneNode(pHead); updateRandomCloneNode(pHead); return splitListNode(pHead); &#125; &#x2F;** * 复制原链表 *&#x2F; public void cloneNode(RandomListNode pHead)&#123; RandomListNode pNode &#x3D; pHead; while(pNode !&#x3D; null)&#123; &#x2F;&#x2F;复制当前节点 RandomListNode cloneNode &#x3D; new RandomListNode(pNode.label); cloneNode.next &#x3D; pNode.next;&#x2F;&#x2F;复制的节点指向原节点的next节点 cloneNode.random &#x3D; null;&#x2F;&#x2F;复制节点的random指针暂时指向为空 pNode.next &#x3D; cloneNode;&#x2F;&#x2F;原节点next指向复制节点 &#x2F;&#x2F;相当于移动指针操作：已复制完一个节点，转向下一个节点 pNode &#x3D; cloneNode.next; &#125; &#125; &#x2F;** * 根据原节点的random指针更新复制节点的random *&#x2F; public void updateRandomCloneNode(RandomListNode pHead)&#123; RandomListNode curNode &#x3D; pHead;&#x2F;&#x2F;当前节点 while(curNode !&#x3D; null)&#123; RandomListNode cloneNode &#x3D; curNode.next; &#x2F;&#x2F;若原节点的random不为空，则更新复制节点的random if(curNode.random !&#x3D; null)&#123; cloneNode.random &#x3D; curNode.random.next; &#125; &#x2F;&#x2F;相当于移动指针操作：已判断完一个节点，转向下一个节点 curNode &#x3D; cloneNode.next; &#125; &#125; &#x2F;** * 拆分链表, *&#x2F; public RandomListNode splitListNode(RandomListNode pHead)&#123; RandomListNode curNode &#x3D; pHead;&#x2F;&#x2F;当前节点 RandomListNode pCloneHead &#x3D; null;&#x2F;&#x2F;新节点head RandomListNode pCloneNode &#x3D; null;&#x2F;&#x2F;新节点指针 &#x2F;&#x2F;初始化 if(curNode !&#x3D; null)&#123; &#x2F;&#x2F;这个地方注意 pCloneHead 和 pCloneNode指针同时指向一个地址， &#x2F;&#x2F;遍历时只移动pCloneNode指针，pCloneHead不变 pCloneHead &#x3D; pCloneNode &#x3D; curNode.next; curNode.next &#x3D; pCloneNode.next; curNode &#x3D; curNode.next; &#125; &#x2F;&#x2F;注意，有4个指针：当前节点指针和其next指针，新节点指针和其next指针 &#x2F;&#x2F;在遍历过程中都要操作这4个指针,其中移动指针是为了继续循环 while(curNode !&#x3D; null)&#123; &#x2F;&#x2F;改变clone节点的next指针 pCloneNode.next &#x3D; curNode.next; &#x2F;&#x2F;移动clone节点指针 pCloneNode &#x3D; pCloneNode.next; &#x2F;&#x2F;改变当前节点的next指针 curNode.next &#x3D; pCloneNode.next; &#x2F;&#x2F;移动当前节点指针 curNode &#x3D; curNode.next; &#125; return pCloneHead; &#125;&#125; 链表之两个链表的第一个公共结点题目描述 输入两个链表，找出它们的第一个公共结点。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; if(pHead1 &#x3D;&#x3D; null || pHead2 &#x3D;&#x3D; null) return null; int len1 &#x3D; getLen(pHead1); int len2 &#x3D; getLen(pHead2); int diff &#x3D; len1 - len2; ListNode nodeLong &#x3D; pHead1; ListNode nodeShort &#x3D; pHead2; if(len2 &gt; len1)&#123; nodeLong &#x3D; pHead2; nodeShort &#x3D; pHead1; diff &#x3D; len2 - len1; &#125; &#x2F;&#x2F;长链表先走diff步 for(int i &#x3D; 0; i &lt; diff; i++)&#123; nodeLong &#x3D; nodeLong.next; &#125; &#x2F;&#x2F;长短链表同时走，直到相遇 或者 没相遇但是都走到了尽头(无相交的情况) while(nodeLong.next !&#x3D; null &amp;&amp; nodeShort.next !&#x3D; null &amp;&amp; nodeLong !&#x3D; nodeShort) &#123; nodeLong &#x3D; nodeLong.next; nodeShort &#x3D; nodeShort.next; &#125; &#x2F;&#x2F;如果走头尽头无相交，则返回null if(nodeLong !&#x3D; nodeShort)&#123; return null; &#125; &#x2F;&#x2F;相遇点即为第一个公共节点 return nodeLong; &#125; &#x2F;** * 获取链表长度 *&#x2F; public int getLen(ListNode listNode)&#123; if(listNode &#x3D;&#x3D; null) return 0; int len &#x3D; 1; while(listNode.next !&#x3D; null)&#123; listNode &#x3D; listNode.next; len++; &#125; return len; &#125;&#125; 链表之链表中环的入口结点题目描述 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。要找到入口结点，只需定义两个指针，一个指针指向 head, 一个指针指向快慢指针的相遇点，然后这两个指针不断遍历（每次走一步），当它们指向同一个结点时即是环的入口结点 12345678910111213141516171819202122232425262728293031public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if(pHead &#x3D;&#x3D; null) return null; ListNode p1 &#x3D; pHead; ListNode p2 &#x3D; pHead; &#x2F;&#x2F;因为p2每次走2步，所以如果无环，跳出循环，返回null while(p2 !&#x3D; null &amp;&amp; p2.next !&#x3D; null)&#123; &#x2F;&#x2F;1、 找环中相遇点：p1走一步，p2走两步 p1 &#x3D; p1.next; p2 &#x3D; p2.next.next; &#x2F;&#x2F;如果环中相遇 if(p1 &#x3D;&#x3D; p2)&#123; &#x2F;&#x2F;2、 找入口：第一次相遇时，使p2指向pHead p2 &#x3D; pHead; while(p1 !&#x3D; p2)&#123; p1 &#x3D; p1.next; p2 &#x3D; p2.next; &#125; &#x2F;&#x2F;跳出循环说明再次相遇，相遇点即为入口 return p1; &#125; &#125; &#x2F;&#x2F;无环 return null; &#125;&#125; 链表之删除链表中重复的结点题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;51234567891011121314151617181920212223242526public class Solution &#123; public ListNode deleteDuplication(ListNode head) &#123; &#x2F;&#x2F;只有一个节点或0个节点 if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head; &#x2F;&#x2F;如果当前节点不是重复节点 if(head.val !&#x3D; head.next.val)&#123; &#x2F;&#x2F;保留当前节点，从下一个节点开始递归 &#x2F;&#x2F;比如，1,2,2,3,4,返回了head &#x3D; 1，且head.next保留了1到2的引用 head.next &#x3D; deleteDuplication(head.next); return head;&#x2F;&#x2F;【当前节点即为表头指针】 &#125; &#x2F;&#x2F;如果当前节点是重复节点 else&#123; ListNode pNode &#x3D; head.next; &#x2F;&#x2F;从下一个节点开始与当前节点比较 while(pNode !&#x3D; null &amp;&amp; pNode.val &#x3D;&#x3D; head.val)&#123; pNode &#x3D; pNode.next; &#125; &#x2F;&#x2F;不保留当前节点，而是保留重复节点中最后一个节点，所以直接return递归即可 &#x2F;&#x2F;比如，1,1,3,4，保留第2个1,返回递归后，第一个1就断掉了。 return deleteDuplication(pNode); &#125; &#125;&#125;","categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"线程池","slug":"线程池","date":"2020-01-03T13:49:49.000Z","updated":"2020-04-07T13:19:04.431Z","comments":true,"path":"2020/01/03/线程池/","link":"","permalink":"http://yoursite.com/2020/01/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"线程池为什么要用线程池？ 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。","text":"线程池为什么要用线程池？ 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 实现Runnable接口和Callable接口的区别Runnable自Java 1.0以来一直存在，但Callable仅在Java 1.5中引入,目的就是为了来处理Runnable不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。 工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））。 执行execute()方法和submit()方法的区别是什么呢？ execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否； submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 如何创建线程池《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 Executors 返回线程池对象的弊端如下： FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。 CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。 方式一：通过构造方法实现 方式二：通过Executor 框架的工具类Executors来实现 我们可以创建三种类型的ThreadPoolExecutor： FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。 SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。 CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。 ThreadPoolExecutor 类分析ThreadPoolExecutor 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。 123456789101112131415161718192021222324&#x2F;** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 *&#x2F;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;&#x3D; 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null) throw new NullPointerException(); this.corePoolSize &#x3D; corePoolSize; this.maximumPoolSize &#x3D; maximumPoolSize; this.workQueue &#x3D; workQueue; this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime); this.threadFactory &#x3D; threadFactory; this.handler &#x3D; handler;&#125; ThreadPoolExecutor构造函数重要参数分析ThreadPoolExecutor 3 个最重要的参数： corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。 maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 ThreadPoolExecutor其他常见参数: keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁； unit : keepAliveTime 参数的时间单位。 threadFactory :executor 创建新线程的时候会用到。 handler :饱和策略。关于饱和策略下面单独介绍一下。 ThreadPoolExecutor 饱和策略ThreadPoolExecutor 饱和策略定义: 如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略: ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。 举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）","categories":[],"tags":[{"name":"Java JUC","slug":"Java-JUC","permalink":"http://yoursite.com/tags/Java-JUC/"}]},{"title":"并发容器","slug":"并发容器","date":"2020-01-03T13:49:31.000Z","updated":"2020-03-29T12:44:03.164Z","comments":true,"path":"2020/01/03/并发容器/","link":"","permalink":"http://yoursite.com/2020/01/03/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/","excerpt":"JDK 提供的并发容器总结JDK 提供的这些容器大部分在 java.util.concurrent 包中。 ConcurrentHashMap: 线程安全的 HashMap CopyOnWriteArrayList: 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector. ConcurrentLinkedQueue: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。 BlockingQueue: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。 ConcurrentSkipListMap: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。","text":"JDK 提供的并发容器总结JDK 提供的这些容器大部分在 java.util.concurrent 包中。 ConcurrentHashMap: 线程安全的 HashMap CopyOnWriteArrayList: 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector. ConcurrentLinkedQueue: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。 BlockingQueue: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。 ConcurrentSkipListMap: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。 ConcurrentHashMap我们知道 HashMap 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 Collections.synchronizedMap() 方法来包装我们的 HashMap。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。 所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。在 ConcurrentHashMap 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。 ConcurrentHashMap 和 Hashtable 的区别ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； 实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 HashTable: JDK1.7的ConcurrentHashMap： JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）： ConcurrentHashMap线程安全的具体实现方式/底层具体实现JDK1.7（上面有示意图）首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。 ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。 Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。 12static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;&#125; 一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。 JDK1.8 （上面有示意图）ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))） synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。 CopyOnWriteArrayList在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问 List 的内部数据，毕竟读取操作是安全的。 CopyOnWriteArrayList 是如何做到的？CopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。 从 CopyOnWriteArrayList 的名字就能看出CopyOnWriteArrayList 是满足CopyOnWrite 的 ArrayList，所谓CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。 CopyOnWriteArrayList 读取操作的实现读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。 1234567891011private transient volatile Object[] array;public E get(int index) &#123; return get(getArray(), index);&#125;@SuppressWarnings(&quot;unchecked&quot;)private E get(Object[] a, int index) &#123; return (E) a[index];&#125;final Object[] getArray() &#123; return array;&#125; CopyOnWriteArrayList 写入操作的实现CopyOnWriteArrayList 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。 1234567891011121314151617181920&#x2F;** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) *&#x2F;public boolean add(E e) &#123; final ReentrantLock lock &#x3D; this.lock; lock.lock();&#x2F;&#x2F;加锁 try &#123; Object[] elements &#x3D; getArray(); int len &#x3D; elements.length; Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);&#x2F;&#x2F;拷贝新数组 newElements[len] &#x3D; e; setArray(newElements); return true; &#125; finally &#123; lock.unlock();&#x2F;&#x2F;释放锁 &#125;&#125; ConcurrentLinkedQueueJava 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。 从名字可以看出，ConcurrentLinkedQueue这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。 ConcurrentLinkedQueue 内部代码我们就不分析了，大家知道 ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全就好了。 ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。 BlockingQueue上面我们己经提到了 ConcurrentLinkedQueue 作为高性能的非阻塞队列。下面我们要讲到的是阻塞队列——BlockingQueue。阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。 ArrayBlockingQueueArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。 ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码： 1private static ArrayBlockingQueue&lt;Integer&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;Integer&gt;(10,true); LinkedBlockingQueueLinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。 ConcurrentSkipListMap为了引出 ConcurrentSkipListMap，先带着大家简单理解一下跳表。 对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 O(logn) 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。 )4[95T1)M0PCP.png) 使用跳表实现 Map 和使用哈希算法实现 Map 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 ConcurrentSkipListMap。","categories":[],"tags":[{"name":"Java JUC","slug":"Java-JUC","permalink":"http://yoursite.com/tags/Java-JUC/"}]},{"title":"Java并发进阶","slug":"Java并发进阶","date":"2020-01-03T12:13:22.000Z","updated":"2020-04-07T13:18:17.514Z","comments":true,"path":"2020/01/03/Java并发进阶/","link":"","permalink":"http://yoursite.com/2020/01/03/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6/","excerpt":"synchronized 关键字synchronized 关键字的了解synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。","text":"synchronized 关键字synchronized 关键字的了解synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 怎么使用 synchronized 关键字synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！ 双重校验锁实现对象单例（线程安全） 1234567891011121314151617181920public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; &#x2F;&#x2F;先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;类对象加锁 synchronized (Singleton.class) &#123; if (uniqueInstance &#x3D;&#x3D; null) &#123; uniqueInstance &#x3D; new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。 uniqueInstance = new Singleton(); 这段代码其实是分为三步执行： 123memory &#x3D; allocate();&#x2F;&#x2F;1.分配对象内存空间instance(memory); &#x2F;&#x2F;2.初始化对象instance &#x3D; memory; &#x2F;&#x2F;3.设置instance执行刚分配的内存地址，此时instance!&#x3D;null 步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化时允许的，如果3步骤提前于步骤2，但是instance还没有初始化完成。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 synchronized 关键字的底层原理synchronized 关键字底层原理属于 JVM 层面。 ① synchronized 同步语句块的情况 1234567public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println(&quot;synchronized 代码块&quot;); &#125; &#125;&#125; 通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息 synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 ② synchronized 修饰方法的的情况 12345public class SynchronizedDemo2 &#123; public synchronized void method() &#123; System.out.println(&quot;synchronized 方法&quot;); &#125;&#125; synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 JDK1.6 之后的底层优化JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。 锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 ①偏向锁 引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。 偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！ ② 轻量级锁 倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。 轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！ ③ 自旋锁和自适应自旋 轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。 互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。 一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。自旋次数的默认值是10次，用户可以修改--XX:PreBlockSpin来更改。 另外,在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。 ④ 锁消除 锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。 ⑤ 锁粗化 原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。 Synchronized 和 ReenTrantLock 的对比① 两者都是可重入锁 “可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。 ② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。 ③ ReenTrantLock 比 synchronized 增加了一些高级功能 ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的 synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” 。 ④ 性能已不是选择标准 DK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作。 volatile关键字Java内存模型Java 内存模型规定了所有的变量都存储在主内存，每条线程都有自己单独的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存，线程间变量值的传递均需要通过主内存来完成。 JMM关于同步的规定： 线程解锁前，必须把共享变量的值刷新回主内存 线程加锁前，必须读取主内存的最新值到自己的工作内存 加锁解锁时同一把锁 volatile是java虚拟机提供的轻量级的同步机制volatile 是 Java 虚拟机提供的最轻量级的同步机制。当一个变量被定义为 volatile 后，它将具备两种特性： 第一是保证此变量对所有线程的可见性，这里的「可见性」是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量则做不到这一点，需要通过主内存来在线程间传递数据。比如，线程 A 修改了一个普通的变量值，然后向主内存进行回写，另一条线程 B 在 A 线程回写完成之后再从主内存进行读写操作，新变量值才会对线程 B 可见。 第二是禁止指令重排优化。普通变量仅仅会保证方法的执行过程中所有依赖赋值结果的地方 能够获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是 Java 内存模型中描述的所谓的「线程内表现为串行的语义」。 synchronized 关键字和 volatile 关键字的区别 volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞 volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。 volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。 Atomic 原子类Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。所以，所谓原子类说简单点就是具有原子/原子操作特征的类。 JUC 包中的原子类是哪4类?基本类型 使用原子的方式更新基本类型 AtomicInteger：整形原子类 AtomicLong：长整型原子类 AtomicBoolean：布尔型原子类 数组类型 使用原子的方式更新数组里的某个元素 AtomicIntegerArray：整形数组原子类 AtomicLongArray：长整形数组原子类 AtomicReferenceArray：引用类型数组原子类 引用类型 AtomicReference：引用类型原子类 AtomicStampedReference：原子更新引用类型里的字段原子类 AtomicMarkableReference ：原子更新带有标记位的引用类型 对象的属性修改类型 AtomicIntegerFieldUpdater：原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 AtomicInteger 的使用1234567public final int get() &#x2F;&#x2F;获取当前的值public final int getAndSet(int newValue)&#x2F;&#x2F;获取当前的值，并设置新的值public final int getAndIncrement()&#x2F;&#x2F;获取当前的值，并自增public final int getAndDecrement() &#x2F;&#x2F;获取当前的值，并自减public final int getAndAdd(int delta) &#x2F;&#x2F;获取当前的值，并加上预期的值boolean compareAndSet(int expect, int update) &#x2F;&#x2F;如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）public final void lazySet(int newValue)&#x2F;&#x2F;最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。 1234567891011class AtomicIntegerTest &#123; private AtomicInteger count &#x3D; new AtomicInteger(); &#x2F;&#x2F;使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。 public void increment() &#123; count.incrementAndGet(); &#125; public int getCount() &#123; return count.get(); &#125;&#125; AtomicInteger 类的原理AtomicInteger 类的部分源码： 123456789101112&#x2F;&#x2F; setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();private static final long valueOffset;static &#123; try &#123; valueOffset &#x3D; unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;private volatile int value; AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 CAS底层原理CAS全称呼Compare-And-Swap，它是一条CPU并发原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成数据不一致问题。 他的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。 1234567public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 &#x3D; this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。 CAS缺点 ** 循环时间长，开销大** 例如getAndAddInt方法执行，有个do while循环，如果CAS失败，一直会进行尝试，如果CAS长时间不成功，可能会给CPU带来很大的开销 只能保证一个共享变量的原子操作 对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性 ABA问题 ​ CAS算法实现一个重要前提需要去除内存中某个时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。 AtomicStampedReference：原子更新带有版本号的引用类型**。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题 CAS与synchronized的使用情景 简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多） 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。 AQSSemaphore(信号量)-允许多个线程同时访问synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制 1234567891011121314151617181920212223public class SemaphoreDemo &#123; public static void main(String[] args) &#123; Semaphore semaphore &#x3D; new Semaphore(3);&#x2F;&#x2F;模拟三个停车位 for (int i &#x3D; 1; i &lt;&#x3D; 6; i++) &#123;&#x2F;&#x2F;模拟6部汽车 new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;\\t抢到车位&quot;); try &#123; TimeUnit.SECONDS.sleep(3);&#x2F;&#x2F;停车3s &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;\\t停车3s后离开车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); &#125; &#125;, &quot;Car &quot; + i).start(); &#125; &#125;&#125; CountDownLatch（倒计时器）CountDownLatch 的三种典型用法① 某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ：new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减 1 countdownlatch.countDown()，当计数器的值变为 0 时，在CountDownLatch上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。 ② 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 ：new CountDownLatch(1)，多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。 ③ 死锁检测：一个非常方便的使用场景是，你可以使用 n 个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。 CountDownLatch主要有两个方法，当一个或多个线程调用await()方法时，调用线程会被阻塞。其他线程调用countDown()方法会将计数器减1，当计数器的值变为0时，因调用await()方法被阻塞的线程才会被唤醒，继续执行 12345678910111213141516public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; countDownLatchTest(); &#125; public static void countDownLatchTest() throws InterruptedException &#123; CountDownLatch countDownLatch &#x3D; new CountDownLatch(6); for (int i &#x3D; 1; i &lt;&#x3D; 6; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+&quot;\\t被灭&quot;); countDownLatch.countDown(); &#125;, CountryEnum.forEach_CountryEnum(i).getRetMessage()).start(); &#125; countDownLatch.await(); System.out.println(Thread.currentThread().getName()+&quot;\\t&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;秦统一&quot;); &#125;&#125; CountDownLatch 的不足CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。 CyclicBarrier(循环栅栏)可循环（Cyclic）使用的屏障。让一组线程到达一个屏障（也可叫同步点）时被阻塞，知道最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CycliBarrier的await()方法 CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。 123456789101112131415161718192021222324public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; cyclicBarrierTest(); &#125; public static void cyclicBarrierTest() &#123; CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(7, () -&gt; &#123; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;召唤神龙&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#125;); for (int i &#x3D; 1; i &lt;&#x3D; 7; i++) &#123; final int tempInt &#x3D; i; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t收集到第&quot; + tempInt + &quot;颗龙珠&quot;); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;&quot; + i).start(); &#125; &#125;&#125; 对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。 CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。 ReentrantLock 和 ReentrantReadWriteLockReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。 ThreadLocalThreadLocal简介通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK中提供的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。 如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。 ThreadLocal原理从 Thread类源代码入手。 123456789public class Thread implements Runnable &#123; ......&#x2F;&#x2F;与此线程有关的ThreadLocal值。由ThreadLocal类维护ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;&#x2F;&#x2F;与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护ThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null; ......&#125; 从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。 ThreadLocal类的set()方法 1234567891011public void set(T value) &#123; Thread t &#x3D; Thread.currentThread(); ThreadLocalMap map &#x3D; getMap(t); if (map !&#x3D; null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。 每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key的键值对。 比如我们在同一个线程中声明了两个 ThreadLocal 对象的话，会使用 Thread内部都是使用仅有那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。 ThreadLocal 内部维护的是一个类似 Map 的ThreadLocalMap 数据结构，key 为当前对象的 Thread 对象，值为 Object 对象。 ThreadLocal 内存泄露问题ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法","categories":[],"tags":[{"name":"Java JUC","slug":"Java-JUC","permalink":"http://yoursite.com/tags/Java-JUC/"}]},{"title":"Java并发基础","slug":"Java并发基础","date":"2020-01-02T13:12:02.000Z","updated":"2020-03-29T12:44:29.875Z","comments":true,"path":"2020/01/02/Java并发基础/","link":"","permalink":"http://yoursite.com/2020/01/02/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/","excerpt":"Java并发基础什么是线程和进程?何为进程?进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。","text":"Java并发基础什么是线程和进程?何为进程?进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 何为线程?线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 请简要描述线程与进程的关系,区别及优缺点)]~HZF$PAJ2.png) 一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的*程序计数器*、虚拟机栈 和 **本地方法栈。 总结： 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。 程序计数器为什么是私有的?程序计数器主要有下面两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 程序计数器私有主要是为了线程切换后能恢复到正确的执行位置 虚拟机栈和本地方法栈为什么是私有的? 虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 ​ 为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。 堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 说说并发与并行的区别? 并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)； 并行： 单位时间内，多个任务同时执行。 为什么要使用多线程呢?先从总体上来说： 从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。 从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。 再深入到计算机底层来探讨： 单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。 多核时代: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。 使用多线程可能带来什么问题?并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。 什么是上下文切换?概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。 什么是线程死锁?如何避免死锁?多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。 如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。 )$MU~~0@WM_@(926L3.png) 123456789101112131415161718192021222324252627282930313233343536public class DeadLockDemo &#123; private static Object resource1 &#x3D; new Object();&#x2F;&#x2F;资源 1 private static Object resource2 &#x3D; new Object();&#x2F;&#x2F;资源 2 public static void main(String[] args) &#123; new Thread(() -&gt; &#123; synchronized (resource1) &#123; System.out.println(Thread.currentThread().getName() + &quot;get resource1&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;waiting get resource2&quot;); synchronized (resource2) &#123; System.out.println(Thread.currentThread().getName() + &quot;get resource2&quot;); &#125; &#125; &#125;, &quot;线程 1&quot;).start(); new Thread(() -&gt; &#123; synchronized (resource2) &#123; System.out.println(Thread.currentThread().getName() + &quot;get resource2&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;waiting get resource1&quot;); synchronized (resource1) &#123; System.out.println(Thread.currentThread().getName() + &quot;get resource1&quot;); &#125; &#125; &#125;, &quot;线程 2&quot;).start(); &#125;&#125; Output 1234线程 1get resource1线程 2get resource2线程 1waiting get resource2线程 2waiting get resource1 学过操作系统的朋友都知道产生死锁必须具备以下四个条件： 互斥条件：该资源任意一个时刻只由一个线程占用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 如何避免线程死锁?我们只要破坏产生死锁的四个条件中的其中一个就可以了。 破坏循环等待条件 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。 我们对线程 2 的代码修改成下面这样就不会产生死锁了。 1234567891011121314new Thread(() -&gt; &#123; synchronized (resource1) &#123; System.out.println(Thread.currentThread() + &quot;get resource1&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;); synchronized (resource2) &#123; System.out.println(Thread.currentThread() + &quot;get resource2&quot;); &#125; &#125;&#125;, &quot;线程 2&quot;).start(); 线程的生命周期和状态?Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态 新建（New）：创建后尚未启动的线程处于这种状态；运行（Runnable）：Runnable 包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着 CPU 为它分配执行时间；无限期等待（Waiting）：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其它线程显式地唤醒；以下三种方法会让线程进入无限期等待状态：没有设置 TimeOut 参数的 Object.wait()；没有设置 TimeOut 参数的 Thread.join()；LockSupport.park()。限期等待（Timed Waiting）：处于这种状态的线程也不会被分配 CPU 执行时间，不过无需等待被其它线程显式地唤醒，在一定时间之后它们会由系统自动唤醒；以下方法会让线程进入限期等待状态：Thread.sleep()；设置了 TimeOut 参数的 Object.wait()；设置了 TimeOut 参数的 Thread.join()；LockSupport.parkNanos()；LockSupport.parkUntil()。阻塞（Blocked）：线程被阻塞了，「阻塞状态」和「等待状态」的区别是：「阻塞状态」在等待着获取一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生；而「等待状态」则是在等待一段时间，或者唤醒动作的发送。在程序等待进入同步区域时，线程将进入这种状态；结束（Terminated）：线程已经结束执行。 sleep() 方法和 wait() 方法区别和共同点? 两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。 两者都可以暂停线程的执行。 Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。 wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。","categories":[],"tags":[{"name":"Java JUC","slug":"Java-JUC","permalink":"http://yoursite.com/tags/Java-JUC/"}]}],"categories":[],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"Java JUC","slug":"Java-JUC","permalink":"http://yoursite.com/tags/Java-JUC/"}]}