<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="二叉树之重建二叉树题目描述  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。" />
  

  
  
  
  
  
  
  <title>二叉树 | 张果果的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="二叉树之重建二叉树题目描述  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树">
<meta property="og:url" content="http://yoursite.com/2020/04/03/%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="张果果的博客">
<meta property="og:description" content="二叉树之重建二叉树题目描述  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-03T13:49:49.000Z">
<meta property="article:modified_time" content="2020-04-07T13:18:27.033Z">
<meta property="article:author" content="张果果的博客">
<meta property="article:tag" content="剑指offer">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 4.2.0"></head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="张果果的博客" rel="home">张果果的博客</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-二叉树" class="post-二叉树 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      二叉树
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2020/04/03/%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="ck8pxlti80003lwr2ec218eaf" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="二叉树之重建二叉树"><a href="#二叉树之重建二叉树" class="headerlink" title="二叉树之重建二叉树"></a>二叉树之重建二叉树</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列-1-2-4-7-3-5-6-8-和中序遍历序列-4-7-2-1-5-3-8-6-，则重建二叉树并返回。"><a href="#输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列-1-2-4-7-3-5-6-8-和中序遍历序列-4-7-2-1-5-3-8-6-，则重建二叉树并返回。" class="headerlink" title="  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。"></a>  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</h6><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</span><br><span class="line">        TreeNode root&#x3D;reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span><br><span class="line">    &#x2F;&#x2F;pre前序列表，mid 中序列表，</span><br><span class="line">    &#x2F;&#x2F;startPre前序的开始序列,endPre前序的结束序列</span><br><span class="line">    &#x2F;&#x2F;startMid 中序的开始序列,endMid 中序的结束序列</span><br><span class="line">    &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    &#x2F;&#x2F;【整理思路】：根据先序和中序序列来构建树及其左右子树</span><br><span class="line">    private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,</span><br><span class="line">                                           int [] mid,int startMid,int endMid) </span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;左右子树构建完成</span><br><span class="line">        if(startPre&gt;endPre||startMid&gt;endMid)</span><br><span class="line">            return null;</span><br><span class="line">        &#x2F;&#x2F;1、先序遍历中确定root节点</span><br><span class="line">        TreeNode root&#x3D;new TreeNode(pre[startPre]);</span><br><span class="line">        &#x2F;&#x2F;2、中序遍历中寻找root节点，然后构建当前root的左右子树root.left root.right，</span><br><span class="line">        for(int i &#x3D; startMid;i &lt;&#x3D; endMid;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;3、中序遍历找到root节点后，确定了左右子树的节点列表，然后用同样的方式(递归)构建左右子树即可</span><br><span class="line">            if(mid[i] &#x3D;&#x3D; pre[startPre])&#123;</span><br><span class="line">                &#x2F;&#x2F;4、关键点：理解先序和中序start和end索引值的计算</span><br><span class="line">                &#x2F;&#x2F;中序的start end很好计算</span><br><span class="line">                &#x2F;&#x2F;先序的start end计算方式： 先计算中序的左子树长度，再根据这个长度i-startMid计算先序的start end</span><br><span class="line">                &#x2F;&#x2F;startPre+(i-startMid)为先序中左子树的end位置,再加上1就是先序的右子树start索引值</span><br><span class="line">                root.left&#x3D;reConstructBinaryTree(pre,startPre+1,startPre+(i-startMid),mid,startMid,i-1);</span><br><span class="line">                root.right&#x3D;reConstructBinaryTree(pre,startPre+(i-startMid)+1,endPre,mid,i+1,endMid);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树之树的子结构"><a href="#二叉树之树的子结构" class="headerlink" title="二叉树之树的子结构"></a>二叉树之树的子结构</h2><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）"><a href="#输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）" class="headerlink" title="  输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）"></a>  输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</h6><p><strong>思路比较简单，就是在A中递归查找是否有B的root节点，有的话再判断该节点的左右节点和B中root的左右节点是否相等。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123;</span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        </span><br><span class="line">        if(root1 !&#x3D; null &amp;&amp; root2 !&#x3D; null)&#123;</span><br><span class="line">            &#x2F;&#x2F;如果root节点相同</span><br><span class="line">            if(root1.val &#x3D;&#x3D; root2.val)&#123;</span><br><span class="line">                &#x2F;&#x2F;判断左右子节点是否相同</span><br><span class="line">                result &#x3D; DoesTree1HasTree2(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果当前层没有找到与B相同的子结构，则继续递归左右子树中寻找</span><br><span class="line">            if(!result) &#123;</span><br><span class="line">              result &#x3D; HasSubtree(root1.left,root2);&#x2F;&#x2F;左子树寻找相同的根节点</span><br><span class="line">            &#125;</span><br><span class="line">            if(!result)&#123;</span><br><span class="line">              result &#x3D; HasSubtree(root1.right,root2);&#x2F;&#x2F;右子树寻找相同的根节点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean DoesTree1HasTree2(TreeNode root1,TreeNode root2)&#123;</span><br><span class="line">        if(root2 &#x3D;&#x3D; null) return true;&#x2F;&#x2F;递归终止条件，B已经到达叶子节点了，说明已经匹配成功！</span><br><span class="line">        if(root1 &#x3D;&#x3D; null) return false;</span><br><span class="line">        </span><br><span class="line">        if(root1.val !&#x3D; root2.val) return false;</span><br><span class="line">        </span><br><span class="line">        return DoesTree1HasTree2(root1.left,root2.left) &amp;&amp; </span><br><span class="line">            DoesTree1HasTree2(root1.right,root2.right);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树之二叉树的镜像"><a href="#二叉树之二叉树的镜像" class="headerlink" title="二叉树之二叉树的镜像"></a>二叉树之二叉树的镜像</h2><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="操作给定的二叉树，将其变换为源二叉树的镜像。"><a href="#操作给定的二叉树，将其变换为源二叉树的镜像。" class="headerlink" title="   操作给定的二叉树，将其变换为源二叉树的镜像。"></a>   操作给定的二叉树，将其变换为源二叉树的镜像。</h6><p><strong>Java递归版本：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public void Mirror(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null || (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null))</span><br><span class="line">            return; </span><br><span class="line">        &#x2F;&#x2F;左右子节点交换</span><br><span class="line">        TreeNode temp &#x3D; root.left;</span><br><span class="line">        root.left &#x3D; root.right;</span><br><span class="line">        root.right &#x3D; temp;</span><br><span class="line">        </span><br><span class="line">        if(root.left !&#x3D; null)</span><br><span class="line">            Mirror(root.left);&#x2F;&#x2F;左子节点递归上述操作</span><br><span class="line">        if(root.right !&#x3D; null) </span><br><span class="line">            Mirror(root.right);&#x2F;&#x2F;右子节点递归上述操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 非递归版本：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public void Mirror(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null || (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null))</span><br><span class="line">            return; </span><br><span class="line">        </span><br><span class="line">        Stack&lt;TreeNode&gt; s &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        while(!s.empty())&#123;</span><br><span class="line">            TreeNode node &#x3D; s.pop();</span><br><span class="line">            &#x2F;&#x2F;左右子节点交换</span><br><span class="line">            TreeNode temp &#x3D; node.left;</span><br><span class="line">            node.left &#x3D; node.right;</span><br><span class="line">            node.right &#x3D; temp;</span><br><span class="line">            </span><br><span class="line">            if(node.left !&#x3D; null)</span><br><span class="line">                s.push(node.left);&#x2F;&#x2F;左子节点递归上述操作</span><br><span class="line">            if(node.right !&#x3D; null) </span><br><span class="line">                s.push(node.right);&#x2F;&#x2F;右子节点递归上述操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树之从上往下打印二叉树"><a href="#二叉树之从上往下打印二叉树" class="headerlink" title="二叉树之从上往下打印二叉树"></a>二叉树之从上往下打印二叉树</h2><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="从上往下打印出二叉树的每个节点，同层节点从左至右打印。"><a href="#从上往下打印出二叉树的每个节点，同层节点从左至右打印。" class="headerlink" title="   从上往下打印出二叉树的每个节点，同层节点从左至右打印。"></a>   从上往下打印出二叉树的每个节点，同层节点从左至右打印。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    if(root &#x3D;&#x3D; null)</span><br><span class="line">        return list;</span><br><span class="line">    &#x2F;&#x2F; 根放入队列</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node &#x3D;  queue.poll();</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        if(node.left !&#x3D; null)</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        if(node.right !&#x3D; null)</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树之二叉树中和为某一值的路径"><a href="#二叉树之二叉树中和为某一值的路径" class="headerlink" title="二叉树之二叉树中和为某一值的路径"></a>二叉树之二叉树中和为某一值的路径</h2><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。-注意-在返回值的list中，数组长度大的数组靠前"><a href="#输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。-注意-在返回值的list中，数组长度大的数组靠前" class="headerlink" title="   输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)"></a>   输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F;最终路径结果列表</span><br><span class="line">    private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;每一条路径，其实是用线性表模拟的栈结构</span><br><span class="line">    private ArrayList&lt;Integer&gt; path &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null ) return result;</span><br><span class="line">        &#x2F;&#x2F;1.入栈</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        &#x2F;&#x2F;2.判断是否叶子节点，且路径和是否满足要求</span><br><span class="line">        boolean isLeaf &#x3D; root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;如果路径值减为0，且当前节点是叶子节点，则满足要求</span><br><span class="line">        if((target - root.val) &#x3D;&#x3D; 0 &amp;&amp; isLeaf)&#123;</span><br><span class="line">            result.add(new ArrayList&lt;Integer&gt;(path));&#x2F;&#x2F;当前路径加入结果列表</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;3.左右子树递归。如果有左右子节点继续以上操作，注意：顺序不能变，先递归左子节点，后递归右子节点</span><br><span class="line">        if(root.left !&#x3D; null) FindPath(root.left,target - root.val);</span><br><span class="line">        if(root.right !&#x3D; null) FindPath(root.right,target - root.val);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;4.出栈，回溯，弹出栈顶元素：深度遍历完成一条路径后，进行回退到父节点的操作</span><br><span class="line">        path.remove(path.size() - 1);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树之二叉树的深度"><a href="#二叉树之二叉树的深度" class="headerlink" title="二叉树之二叉树的深度"></a>二叉树之二叉树的深度</h2><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。"><a href="#输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。" class="headerlink" title="   输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。"></a>   输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int TreeDepth(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return 0;</span><br><span class="line">        </span><br><span class="line">        int nLeft &#x3D; TreeDepth(root.left);  &#x2F;&#x2F;左子树的深度</span><br><span class="line">        int nRight &#x3D; TreeDepth(root.right);&#x2F;&#x2F;右子树的深度</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;若无子节点，则返回深度是1</span><br><span class="line">        return 1 + Math.max(nLeft,nRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树之平衡二叉树"><a href="#二叉树之平衡二叉树" class="headerlink" title="二叉树之平衡二叉树"></a>二叉树之平衡二叉树</h2><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="输入一棵二叉树，判断该二叉树是否是平衡二叉树。"><a href="#输入一棵二叉树，判断该二叉树是否是平衡二叉树。" class="headerlink" title="   输入一棵二叉树，判断该二叉树是否是平衡二叉树。"></a>   输入一棵二叉树，判断该二叉树是否是平衡二叉树。</h6><h4 id="平衡二叉树概念"><a href="#平衡二叉树概念" class="headerlink" title="平衡二叉树概念"></a>平衡二叉树概念</h4><h6 id="每一个节点的左右子树的高度差的绝对值不大于1，或者本身是空树。"><a href="#每一个节点的左右子树的高度差的绝对值不大于1，或者本身是空树。" class="headerlink" title="   每一个节点的左右子树的高度差的绝对值不大于1，或者本身是空树。"></a>   每一个节点的左右子树的高度差的绝对值不大于1，或者本身是空树。</h6><p><strong>实现一，从上到下遍历的思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean IsBalanced_Solution(TreeNode pRoot) &#123;</span><br><span class="line">		if (pRoot &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		int left &#x3D; TreeDepth(pRoot.left);</span><br><span class="line">		int right &#x3D; TreeDepth(pRoot.right);</span><br><span class="line">		int diff &#x3D; left - right;</span><br><span class="line">		&#x2F;&#x2F;判断高度差</span><br><span class="line">		if (diff &gt; 1 || diff &lt; -1) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;由于从上到下的遍历思想，所以左右子节点也要同样的判断，这里就导致了底层的树深会被计算多次，增加额外开销。</span><br><span class="line">		return IsBalanced_Solution(pRoot.right)</span><br><span class="line">				&amp;&amp; IsBalanced_Solution(pRoot.left);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private int TreeDepth(TreeNode pRoot) &#123;</span><br><span class="line">		if (pRoot &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		int left &#x3D; TreeDepth(pRoot.left);</span><br><span class="line">		int right &#x3D; TreeDepth(pRoot.right);</span><br><span class="line">		return 1 + Math.max(left,right);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现二，剪枝思路，从下到上遍历的思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean IsBalanced_Solution(TreeNode root) &#123;</span><br><span class="line">        return getDepth(root) !&#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    private int getDepth(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return 0;</span><br><span class="line">        &#x2F;&#x2F;左子树深度</span><br><span class="line">        int left &#x3D; getDepth(root.left);</span><br><span class="line">        if (left &#x3D;&#x3D; -1) return -1;&#x2F;&#x2F;剪枝</span><br><span class="line">        &#x2F;&#x2F;右子树深度</span><br><span class="line">        int right &#x3D; getDepth(root.right);</span><br><span class="line">        if (right &#x3D;&#x3D; -1) return -1;&#x2F;&#x2F;剪枝</span><br><span class="line">        &#x2F;&#x2F;左右子树的深度差的绝对值大于1，不是平衡二叉树，直接返回-1； 否则，返回树深</span><br><span class="line">        return Math.abs(left - right) &gt; 1 ? -1 : 1 + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树之二叉树的下一个结点"><a href="#二叉树之二叉树的下一个结点" class="headerlink" title="二叉树之二叉树的下一个结点"></a>二叉树之二叉树的下一个结点</h2><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。"><a href="#给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。" class="headerlink" title="   给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。"></a>   给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</h6><p>​     ① 如果节点有右子树，它的下一个节点就是右子树的最左节点，比如a的下一个节点就是a.right.left = f，e的下一个节点就是e.right= i。<br>   ②如果节点没有右子树，且是它的父节点的左子节点，那么下一个节点就是它的父节点，比如 h.next = e。<br>   ③如果节点没有右子树，且是它的父节点的右子节点，那么下一个节点稍微有点复杂，需要往上遍历一直找到是它的父节点的左子节点的节点，比如i.next.next = b，b是左子节点，所以此时，b的父节点就是下一个节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeLinkNode GetNext(TreeLinkNode pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pNode &#x3D;&#x3D; null) return null;</span><br><span class="line">        TreeLinkNode pNext &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;1.如果有右子树，求右子树的最左节点</span><br><span class="line">        if(pNode.right !&#x3D; null)&#123;</span><br><span class="line">            pNode &#x3D; pNode.right;</span><br><span class="line">            while(pNode.left !&#x3D; null)&#123;</span><br><span class="line">                pNode &#x3D; pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            pNext &#x3D; pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;2.如果没有右子树</span><br><span class="line">        else if(pNode.next !&#x3D; null)&#123;</span><br><span class="line">            </span><br><span class="line">            TreeLinkNode parent &#x3D; pNode.next;&#x2F;&#x2F;父节点</span><br><span class="line">            &#x2F;&#x2F;如果该节点为其父节点的右子节点</span><br><span class="line">            while(parent !&#x3D; null &amp;&amp; pNode &#x3D;&#x3D; parent.right)&#123;</span><br><span class="line">                &#x2F;&#x2F;往上寻找，画图好理解</span><br><span class="line">                pNode &#x3D; parent;</span><br><span class="line">                parent &#x3D; pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;跳出循环，此时的pNode是它的父节点的左子节点的节点，此时的parent就是下一个节点</span><br><span class="line">            pNext &#x3D; parent;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树之对称的二叉树"><a href="#二叉树之对称的二叉树" class="headerlink" title="二叉树之对称的二叉树"></a>二叉树之对称的二叉树</h2><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。"><a href="#请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。" class="headerlink" title="   请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。"></a>   请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    boolean isSymmetrical(TreeNode pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRoot &#x3D;&#x3D; null) return true;</span><br><span class="line">        </span><br><span class="line">        return compareRoot(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     ** 递归其实是比较的两个节点的值</span><br><span class="line">     *  形参虽然写的是left和right，但不一定表示的是同一个节点的左右子树</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean compareRoot(TreeNode left, TreeNode right) &#123;</span><br><span class="line">        &#x2F;&#x2F;只有一个根节点</span><br><span class="line">        if(left &#x3D;&#x3D; null &amp;&amp; right &#x3D;&#x3D;null) return true;</span><br><span class="line">        &#x2F;&#x2F;左右子节点不相等:一个为null,另一个不为null</span><br><span class="line">        if(left &#x3D;&#x3D; null || right &#x3D;&#x3D; null) return false;</span><br><span class="line">        &#x2F;&#x2F;条件，需要考虑3层</span><br><span class="line">        &#x2F;&#x2F;①左右子节点相等</span><br><span class="line">        &#x2F;&#x2F;②左子节点的左子节点 &#x3D;&#x3D; 右子节点的右子节点</span><br><span class="line">        &#x2F;&#x2F;③左子节点的右子节点 &#x3D;&#x3D; 右子节点的左子节点</span><br><span class="line">        return left.val &#x3D;&#x3D; right.val &amp;&amp; compareRoot(left.left,right.right) &amp;&amp; compareRoot(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树之按之字形顺序打印二叉树"><a href="#二叉树之按之字形顺序打印二叉树" class="headerlink" title="二叉树之按之字形顺序打印二叉树"></a>二叉树之按之字形顺序打印二叉树</h2><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。"><a href="#请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。" class="headerlink" title="   请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。"></a>   请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</h6><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h6 id="关键点：-用两个栈分别保存奇数层和偶数层的节点。"><a href="#关键点：-用两个栈分别保存奇数层和偶数层的节点。" class="headerlink" title="   关键点： 用两个栈分别保存奇数层和偶数层的节点。"></a>   关键点： 用两个栈分别保存奇数层和偶数层的节点。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F;final</span><br><span class="line">        Stack&lt;TreeNode&gt; s1 &#x3D; new Stack&lt;&gt;();&#x2F;&#x2F;奇数层栈</span><br><span class="line">        s1.push(pRoot);&#x2F;&#x2F;初始化</span><br><span class="line">        Stack&lt;TreeNode&gt; s2 &#x3D; new Stack&lt;&gt;();&#x2F;&#x2F;偶数层栈</span><br><span class="line">        int layer &#x3D; 1; &#x2F;&#x2F;记录奇数偶数的标识</span><br><span class="line">        </span><br><span class="line">        while(!s1.isEmpty() || !s2.isEmpty())&#123;</span><br><span class="line">            &#x2F;&#x2F;保存每层节点数据</span><br><span class="line">            ArrayList&lt;Integer&gt; layerList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F;如果是奇数层</span><br><span class="line">            if(layer % 2 !&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F;遍历奇数栈中每一个节点，打印同时将其子节点放入偶数栈中</span><br><span class="line">                while(!s1.isEmpty())&#123;</span><br><span class="line">                    TreeNode node &#x3D; s1.pop();</span><br><span class="line">                    if(node !&#x3D; null)&#123;</span><br><span class="line">                        layerList.add(node.val);&#x2F;&#x2F;打印</span><br><span class="line">                        &#x2F;&#x2F;将左右子树加入偶数栈</span><br><span class="line">                        s2.push(node.left);</span><br><span class="line">                        s2.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;当前层放入最终列表中</span><br><span class="line">                if(!layerList.isEmpty())&#123;</span><br><span class="line">                    result.add(layerList);</span><br><span class="line">                    layerList &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                layer++;&#x2F;&#x2F;处理完一层后，改变奇偶标识符</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果是偶数层</span><br><span class="line">            else&#123;</span><br><span class="line">                &#x2F;&#x2F;遍历偶数栈中每一个节点，打印同时将其子节点放入奇数栈中</span><br><span class="line">                while(!s2.isEmpty())&#123;</span><br><span class="line">                    TreeNode node &#x3D; s2.pop();</span><br><span class="line">                    if(node !&#x3D; null)&#123;</span><br><span class="line">                        layerList.add(node.val);&#x2F;&#x2F;打印</span><br><span class="line">                        &#x2F;&#x2F;将左右子树加入奇数栈</span><br><span class="line">                        &#x2F;&#x2F;由于奇数栈打印是从左往右，所以奇数栈入栈要从右往左</span><br><span class="line">                        s1.push(node.right);</span><br><span class="line">                        s1.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;当前层放入最终列表中</span><br><span class="line">                if(!layerList.isEmpty())&#123;</span><br><span class="line">                    result.add(layerList);</span><br><span class="line">                    layerList &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                layer++;&#x2F;&#x2F;处理完一层后，改变奇偶标识符</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树之序列化二叉树"><a href="#二叉树之序列化二叉树" class="headerlink" title="二叉树之序列化二叉树"></a>二叉树之序列化二叉树</h2><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="请实现两个函数，分别用来序列化和反序列化二叉树"><a href="#请实现两个函数，分别用来序列化和反序列化二叉树" class="headerlink" title="   请实现两个函数，分别用来序列化和反序列化二叉树"></a>   请实现两个函数，分别用来序列化和反序列化二叉树</h6><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><h6 id="这题其实挺开放的，没规定具体的序列化规则，我们可以使用先序遍历的方式，"><a href="#这题其实挺开放的，没规定具体的序列化规则，我们可以使用先序遍历的方式，" class="headerlink" title="   这题其实挺开放的，没规定具体的序列化规则，我们可以使用先序遍历的方式，"></a>   这题其实挺开放的，没规定具体的序列化规则，我们可以使用先序遍历的方式，</h6><h6 id="①-序列化规则：-表示空，节点之前用，分隔。"><a href="#①-序列化规则：-表示空，节点之前用，分隔。" class="headerlink" title="   ① 序列化规则：#表示空，节点之前用，分隔。"></a>   ① 序列化规则：#表示空，节点之前用，分隔。</h6><h6 id="②-反序列化规则：相当于重建二叉树，可以参考之前的博客。"><a href="#②-反序列化规则：相当于重建二叉树，可以参考之前的博客。" class="headerlink" title="   ② 反序列化规则：相当于重建二叉树，可以参考之前的博客。"></a>   ② 反序列化规则：相当于重建二叉树，可以参考之前的博客。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int index &#x3D; -1;</span><br><span class="line">    String Serialize(TreeNode root) &#123;</span><br><span class="line">        StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            sb.append(&quot;#,&quot;);</span><br><span class="line">            return sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;先序遍历</span><br><span class="line">        sb.append(root.val+&quot;,&quot;);&#x2F;&#x2F;先根</span><br><span class="line">        sb.append(Serialize(root.left));&#x2F;&#x2F;后左</span><br><span class="line">        sb.append(Serialize(root.right));&#x2F;&#x2F;最后右</span><br><span class="line">        </span><br><span class="line">        return sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line">    TreeNode Deserialize(String str) &#123;</span><br><span class="line">       index++;&#x2F;&#x2F;计数指针，为什么起作用？ </span><br><span class="line">               &#x2F;&#x2F;因为左树构造完了才会构造右子树，跟序列化时顺序一致，所以递归时顺序才能对上</span><br><span class="line">       if(index &gt;&#x3D; str.length())&#123;</span><br><span class="line">          return null;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       String[] strr &#x3D; str.split(&quot;,&quot;);</span><br><span class="line">       TreeNode node &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;递归终止条件，碰到#号</span><br><span class="line">       if(!strr[index].equals(&quot;#&quot;))&#123;</span><br><span class="line">          &#x2F;&#x2F;按照顺序：根、左、右构造二叉树</span><br><span class="line">          node &#x3D; new TreeNode(Integer.valueOf(strr[index]));</span><br><span class="line">          node.left &#x3D; Deserialize(str);</span><br><span class="line">          node.right &#x3D; Deserialize(str);</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       return node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树之二叉搜索树的后序遍历序列"><a href="#二叉搜索树之二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树之二叉搜索树的后序遍历序列"></a>二叉搜索树之二叉搜索树的后序遍历序列</h2><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes-否则输出No。假设输入的数组的任意两个数字都互不相同。"><a href="#输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes-否则输出No。假设输入的数组的任意两个数字都互不相同。" class="headerlink" title="   输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。"></a>   输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean VerifySquenceOfBST(int [] sequence) &#123;</span><br><span class="line">        return bst(sequence,0,sequence.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean bst(int [] sequence,int begin,int end)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sequence &#x3D;&#x3D; null || sequence.length &#x3D;&#x3D; 0) return false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1.确定根节点</span><br><span class="line">        int root &#x3D; sequence[end];</span><br><span class="line">        int i &#x3D; begin;&#x2F;&#x2F;左子树起始索引</span><br><span class="line">        &#x2F;&#x2F;2.确定左右子树分解点，通过遍历左子树</span><br><span class="line">        for(;i &lt; end ; i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;当找到第一个大于root的数值时，即找到了左右子树的分界点</span><br><span class="line">            if(sequence[i] &gt; root) break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int j &#x3D; i;&#x2F;&#x2F;右子树起始索引</span><br><span class="line">        &#x2F;&#x2F;3.判断右子树符不符合二叉搜索树的特性</span><br><span class="line">        for(; j &lt; end; j++)&#123;</span><br><span class="line">            &#x2F;&#x2F;右子树中有小于root的数值，return fasle</span><br><span class="line">            if(sequence[j] &lt; root) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;4.左右子树递归，判断左子树是不是二叉搜索树</span><br><span class="line">        boolean left &#x3D; true;</span><br><span class="line">        if(i &gt; begin)&#123;</span><br><span class="line">            left &#x3D; bst(sequence,begin, i-1);&#x2F;&#x2F;i-1 为左子树的倒数第一个索引</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;递归判断右子树是不是二叉搜索树</span><br><span class="line">        boolean right &#x3D; true;</span><br><span class="line">        if(i &lt; end -1 )&#123;</span><br><span class="line">            right &#x3D; bst(sequence,i, end - 1);&#x2F;&#x2F;end - 1为数组倒数第2个节点:右子树的倒数第一个索引</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树之二叉搜索树与双向链表"><a href="#二叉搜索树之二叉搜索树与双向链表" class="headerlink" title="二叉搜索树之二叉搜索树与双向链表"></a>二叉搜索树之二叉搜索树与双向链表</h2><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。"><a href="#输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。" class="headerlink" title="   输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。"></a>   输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    private TreeNode tail &#x3D; null;&#x2F;&#x2F;链表尾节点</span><br><span class="line">    private TreeNode head &#x3D; null;&#x2F;&#x2F;链表头结点</span><br><span class="line">    public TreeNode Convert(TreeNode pRootOfTree) &#123;</span><br><span class="line">        if(pRootOfTree &#x3D;&#x3D; null ) return null;</span><br><span class="line">        </span><br><span class="line">        ConvertNode(pRootOfTree);&#x2F;&#x2F;开始转换</span><br><span class="line">        </span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 二叉树转双向链表核心方法</span><br><span class="line">	 * @param root</span><br><span class="line">	 * @param pLastNodeInList</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void ConvertNode(TreeNode pRootOfTree) &#123;</span><br><span class="line">		if(pRootOfTree &#x3D;&#x3D; null) return;&#x2F;&#x2F;校验</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;递归左子树</span><br><span class="line">		ConvertNode(pRootOfTree.left);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;第一次执行下面这块时，是在最左子树的最左叶子节点,此时的pRootOfTree&#x3D;4就是叶子节点本身        </span><br><span class="line">        &#x2F;&#x2F;初始化链表的头节点和尾节点（每次递归，链表新增加节点时，都需要改动tail）</span><br><span class="line">        if(head &#x3D;&#x3D; null)&#123;</span><br><span class="line">            head &#x3D; pRootOfTree;&#x2F;&#x2F;head &#x3D;4</span><br><span class="line">            tail &#x3D; pRootOfTree;&#x2F;&#x2F;tail &#x3D; 4</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;通过递归退回到父节点，此时的pRootOfTree&#x3D;6就是父节点本身</span><br><span class="line">        else&#123;</span><br><span class="line">            &#x2F;&#x2F;实现双向链表,比如4.right&#x3D;6，6.left&#x3D;4</span><br><span class="line">            tail.right &#x3D; pRootOfTree;</span><br><span class="line">            pRootOfTree.left &#x3D; tail;</span><br><span class="line">            &#x2F;&#x2F;此时链表新加了节点pRootOfTree&#x3D;6，所以tail需要改成6</span><br><span class="line">            tail &#x3D; pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		&#x2F;&#x2F;递归右子树</span><br><span class="line">		ConvertNode(pRootOfTree.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树之二叉搜索树的第k个结点"><a href="#二叉搜索树之二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树之二叉搜索树的第k个结点"></a>二叉搜索树之二叉搜索树的第k个结点</h2><h4 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="给定一棵二叉搜索树，请找出其中的第k小的结点。例如，-（5，3，7，2，4，6，8）-中，按结点数值大小顺序第三小结点的值为4。"><a href="#给定一棵二叉搜索树，请找出其中的第k小的结点。例如，-（5，3，7，2，4，6，8）-中，按结点数值大小顺序第三小结点的值为4。" class="headerlink" title="   给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。"></a>   给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    private int index &#x3D; 0;&#x2F;&#x2F;计数器</span><br><span class="line">    TreeNode KthNode(TreeNode pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRoot &#x3D;&#x3D; null || k &lt; 0) return null;</span><br><span class="line">        </span><br><span class="line">        return KthNodeCore(pRoot, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode KthNodeCore(TreeNode pRoot, int k)&#123;</span><br><span class="line">        if(pRoot &#x3D;&#x3D; null) return null;</span><br><span class="line">        &#x2F;&#x2F;左子树中查找</span><br><span class="line">        TreeNode node &#x3D; KthNodeCore(pRoot.left,k);</span><br><span class="line">        if(node !&#x3D; null) return node;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;根节点</span><br><span class="line">        index++;</span><br><span class="line">        if(index &#x3D;&#x3D; k) return pRoot;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;右子树中查找</span><br><span class="line">        node &#x3D; KthNodeCore(pRoot.right,k);</span><br><span class="line">        if(node !&#x3D; null) return node;</span><br><span class="line">        </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/04/03/%E4%BA%8C%E5%8F%89%E6%A0%91/">
    <time datetime="2020-04-03T13:49:49.000Z" class="entry-date">
        2020-04-03
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a></li></ul>

    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
    
        <span class="nav-next"><a href="/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="next">字符串 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2020/04/03/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
          </li>
        
          <li>
            <a href="/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
          </li>
        
          <li>
            <a href="/2020/04/03/%E6%95%B0%E7%BB%84/">数组</a>
          </li>
        
          <li>
            <a href="/2020/04/03/%E9%93%BE%E8%A1%A8/">链表</a>
          </li>
        
          <li>
            <a href="/2020/01/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-JUC/" rel="tag">Java JUC</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a><span class="tag-list-count">4</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/Java-JUC/" style="font-size: 10px;">Java JUC</a> <a href="/tags/%E5%89%91%E6%8C%87offer/" style="font-size: 10px;">剑指offer</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 张果果的博客
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>