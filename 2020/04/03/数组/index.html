<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="数组二维数组查找【找规律】题目描述  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。" />
  

  
  
  
  
  
  
  <title>数组 | 张果果的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="数组二维数组查找【找规律】题目描述  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。">
<meta property="og:type" content="article">
<meta property="og:title" content="数组">
<meta property="og:url" content="http://yoursite.com/2020/04/03/%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="张果果的博客">
<meta property="og:description" content="数组二维数组查找【找规律】题目描述  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-03T13:49:49.000Z">
<meta property="article:modified_time" content="2020-04-07T13:18:47.024Z">
<meta property="article:author" content="张果果的博客">
<meta property="article:tag" content="剑指offer">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 4.2.0"></head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="张果果的博客" rel="home">张果果的博客</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-数组" class="post-数组 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      数组
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2020/04/03/%E6%95%B0%E7%BB%84/" data-id="ck8pxltic0008lwr2gy6iaw92" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二维数组查找【找规律】"><a href="#二维数组查找【找规律】" class="headerlink" title="二维数组查找【找规律】"></a>二维数组查找【找规律】</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。"><a href="#在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。" class="headerlink" title="  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。"></a>  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<a id="more"></a></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">	public boolean find(int target,int[][] array)&#123;</span><br><span class="line">		if(array.length&lt;0 ) return false; &#x2F;&#x2F;参数校验</span><br><span class="line">		&#x2F;&#x2F; 从二维数组的最右上角开始查找。</span><br><span class="line">		int row &#x3D; 0; &#x2F;&#x2F;当前行</span><br><span class="line">		int col &#x3D; array[0].length -1 ; &#x2F;&#x2F;当前列</span><br><span class="line">		while(row &gt; array.length &amp;&amp; col &gt;&#x3D;0)&#123;</span><br><span class="line">			&#x2F;&#x2F;如果最右上角的数字小于target，直接干掉当前行，row++</span><br><span class="line">			if(array[row][col]&lt; target)&#123;</span><br><span class="line">				row ++;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;如果最右上角的数字大于target，直接干掉当前列，col--</span><br><span class="line">			if(array[row][col]&gt; target)&#123;</span><br><span class="line">				col --;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				return ture;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组之旋转数组的最小数字【特殊二分查找】"><a href="#数组之旋转数组的最小数字【特殊二分查找】" class="headerlink" title="数组之旋转数组的最小数字【特殊二分查找】"></a>数组之旋转数组的最小数字【特殊二分查找】</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>  把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int minNumberInRotateArray(int [] array) &#123;</span><br><span class="line">        int len&#x3D;array.length;</span><br><span class="line">        int left&#x3D;0;</span><br><span class="line">        int right&#x3D;len-1;</span><br><span class="line">           while(start &lt; end)&#123;</span><br><span class="line">            &#x2F;&#x2F;左右指针相邻</span><br><span class="line">            if(end - start &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                mid &#x3D; end;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            mid &#x3D; (start+end) &gt;&gt; 1;</span><br><span class="line">            &#x2F;&#x2F;特殊情况 11011</span><br><span class="line">            if(array[mid] &#x3D;&#x3D; array[start] &amp;&amp; array[start] &#x3D;&#x3D; array[end])&#123;</span><br><span class="line">                return findInOrder(array,start,end);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;mid在左边递增数组中，最小值在右边，移动左指针</span><br><span class="line">            if(array[mid] &gt;&#x3D; array[start])&#123;</span><br><span class="line">                start &#x3D; mid ;</span><br><span class="line">            &#125;else&#123;&#x2F;&#x2F;mid 在右边递增数组中，最小值在左边，移动右指针</span><br><span class="line">                end &#x3D; mid ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return array[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;顺序查找</span><br><span class="line">    public int findInOrder(int [] array,int start,int end)&#123;</span><br><span class="line">        int minNum &#x3D; array[start];</span><br><span class="line">        for(int i&#x3D; start+1;i&lt;end;i++)&#123;</span><br><span class="line">            if(array[i] &lt; minNum)&#123;</span><br><span class="line">                minNum &#x3D; array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组之调整数组顺序使奇数位于偶数前面【特殊快速排序】"><a href="#数组之调整数组顺序使奇数位于偶数前面【特殊快速排序】" class="headerlink" title="数组之调整数组顺序使奇数位于偶数前面【特殊快速排序】"></a>数组之调整数组顺序使奇数位于偶数前面【特殊快速排序】</h2><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。"><a href="#输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。" class="headerlink" title="  输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。"></a>  输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean reOrderArray(int [] array) &#123;</span><br><span class="line">        &#x2F;&#x2F;校验入参</span><br><span class="line">        if(array.length &lt; 0 )&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int a&#x3D;0,b&#x3D;array.length-1,temp;</span><br><span class="line">        while(a&lt;b)&#123;</span><br><span class="line">			if(arr[a]%2&#x3D;&#x3D;1) a++;</span><br><span class="line">			if(arr[b]%2&#x3D;&#x3D;0) b--;</span><br><span class="line">			if((arr[a]%2&#x3D;&#x3D;0)&amp;&amp;(arr[b]%2&#x3D;&#x3D;1))</span><br><span class="line">			&#123;</span><br><span class="line">				temp&#x3D;arr[a];</span><br><span class="line">				arr[a]&#x3D;arr[b];</span><br><span class="line">				arr[b]&#x3D;temp;</span><br><span class="line">				a++;</span><br><span class="line">				b--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return ture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组之数组中出现次数超过一半的数字"><a href="#数组之数组中出现次数超过一半的数字" class="headerlink" title="数组之数组中出现次数超过一半的数字"></a>数组之数组中出现次数超过一半的数字</h2><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组-1-2-3-2-2-2-5-4-2-。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。"><a href="#数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组-1-2-3-2-2-2-5-4-2-。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。" class="headerlink" title="  数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。"></a>  数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</h6><p>1.快速排序</p>
<p>在随机快速排序算法中，我们先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小数字都排在它的左边，比选中的数字大的数字都排在它的右边。如果这个选中的数字的下标刚好是n/2，那么这个数字就是数组的中位数。如果它的下标大于n/2，那么中位数应该位于它的左边，我们可以接着在它的左边部分的数组中查找。如果它的下标小于n/2，那么中位数应该位于它的右边，我们可以接着在它的右边部分的数组中查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int moreThanHalfNum(int[] array, int length)&#123;</span><br><span class="line">	if(if(array &#x3D;&#x3D; null &amp;&amp; length &lt;&#x3D; 0)&#123;)&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	int middle &#x3D; length &gt;&gt; 1;</span><br><span class="line">	int start &#x3D; 0;</span><br><span class="line">	int end &#x3D; length - 1;</span><br><span class="line">	int index &#x3D; Partition(array, length, start, end);</span><br><span class="line">	&#x2F;&#x2F; 寻找中位数</span><br><span class="line">	while(index !&#x3D; middle)&#123;</span><br><span class="line">		&#x2F;&#x2F; 如果得到 index 大于中间值，则往前半部分查找</span><br><span class="line">		if(index &gt; middle)&#123;</span><br><span class="line">			end &#x3D; index - 1;</span><br><span class="line">			index &#x3D; Partition(array, length, start, end);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			start &#x3D; index + 1;</span><br><span class="line">			index &#x3D; Partition(array, length, start, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int result &#x3D; array[middle];</span><br><span class="line">	if(!CheckMoreThanHalf(array, length, result))&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">boolean CheckMoreThanHalf(int[] array, int length, int number)&#123;</span><br><span class="line">	int times &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">		if(array[i] &#x3D; number)&#123;</span><br><span class="line">			times++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	boolean isMoreThanHalf &#x3D; true;</span><br><span class="line">	if(times * 2 &lt;&#x3D; length)&#123;</span><br><span class="line">		isMoreThanHalf &#x3D; false;</span><br><span class="line">	&#125;</span><br><span class="line">	return isMoreThanHalf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.数组中有一个数字出现的次数超过数组长度的一半，也就是说<strong>它出现的次数比其他所有数字出现次数的和还要多</strong>。因此我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。</p>
<ul>
<li>当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；</li>
<li>如果下一个数字和我们之前保存的数字不同，则次数减1。</li>
<li>如果次数为零，我们需要保存下一个数字，并把次数设为1。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> public Integer moreThanHalfNum(int[] array) &#123;</span><br><span class="line">	if (array &#x3D;&#x3D; null)</span><br><span class="line">		return null;</span><br><span class="line">	Integer number &#x3D; null;</span><br><span class="line">	int count &#x3D; 0;</span><br><span class="line">	Integer resultInteger &#x3D; null;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">		if (number &#x3D;&#x3D; null) &#123;</span><br><span class="line">			number &#x3D; array[i];</span><br><span class="line">			count++;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (array[i] !&#x3D; number)</span><br><span class="line">				if (count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					number &#x3D; array[i];</span><br><span class="line">					count &#x3D; 1;</span><br><span class="line">				&#125; else</span><br><span class="line">					count--;</span><br><span class="line">			else</span><br><span class="line">				count++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (count &#x3D;&#x3D; 1)</span><br><span class="line">			resultInteger &#x3D; number;</span><br><span class="line">	&#125;</span><br><span class="line">	if (checkMoreThanHalf(array, resultInteger))</span><br><span class="line">		return resultInteger;</span><br><span class="line">	else</span><br><span class="line">		return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组之连续子数组的最大和【动态规划】"><a href="#数组之连续子数组的最大和【动态规划】" class="headerlink" title="数组之连续子数组的最大和【动态规划】"></a>数组之连续子数组的最大和【动态规划】</h2><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="给一个整型数组，有正有负，数组中的一个或连续多个组成子序列，返回所有连续子序列中和的最大值。例如-6-3-2-7-15-1-2-2-连续子序列和的最大值为8。"><a href="#给一个整型数组，有正有负，数组中的一个或连续多个组成子序列，返回所有连续子序列中和的最大值。例如-6-3-2-7-15-1-2-2-连续子序列和的最大值为8。" class="headerlink" title="  给一个整型数组，有正有负，数组中的一个或连续多个组成子序列，返回所有连续子序列中和的最大值。例如:{6,-3,-2,7,-15,1,2,2},连续子序列和的最大值为8。"></a>  给一个整型数组，有正有负，数组中的一个或连续多个组成子序列，返回所有连续子序列中和的最大值。例如:{6,-3,-2,7,-15,1,2,2},连续子序列和的最大值为8。</h6><ul>
<li>只考虑第一个元素，则最大子段和为其本身 DP[0] = nums[0]</li>
<li>考虑前两个元素，最大子段和为 nums[0],num[1]以及 nums[0] + num[1] 中最大值 设为DP[1]</li>
<li>考虑前三个元素，如何求其最大子段和？还是分为两种情况讨论，第三个元素在最后的字串内吗？</li>
<li>若第三个元素也包含在最后的字串内，则DP[2] = Max(DP[1]+nums[2] , nums[2])</li>
</ul>
<p><strong>初始状态</strong></p>
<p>dp[0] = nums[0]</p>
<p>dp[1] = max(dp[0]+nums[1] , nums[1])</p>
<p><strong>状态转移方程：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class lc53_MaximumSubarray &#123;</span><br><span class="line">  public int maxSubArray(int[] nums) &#123;</span><br><span class="line">    int len &#x3D; nums.length;</span><br><span class="line">    if(len &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    </span><br><span class="line">    int [] dp &#x3D; new int[len];</span><br><span class="line">    dp[0] &#x3D; nums[0];</span><br><span class="line">    int max &#x3D; dp[0];</span><br><span class="line">    for (int i &#x3D; 1; i&lt;len;i++)&#123;</span><br><span class="line">      dp[i] &#x3D; (dp[i-1]+nums[i] &gt; nums[i]) ? dp[i-1]+nums[i] : nums[i];</span><br><span class="line">      if (dp[i]&gt;max)</span><br><span class="line">        max &#x3D; dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组之把数组排成最小的数"><a href="#数组之把数组排成最小的数" class="headerlink" title="数组之把数组排成最小的数"></a>数组之把数组排成最小的数</h2><h6 id="排序规则：输入a-b"><a href="#排序规则：输入a-b" class="headerlink" title="   排序规则：输入a,b"></a>   排序规则：输入a,b</h6><h6 id="①-若ab-gt-ba-，因为ba小，所以b应该排在a前面，即a-gt-b"><a href="#①-若ab-gt-ba-，因为ba小，所以b应该排在a前面，即a-gt-b" class="headerlink" title="   ① 若ab &gt; ba ，因为ba小，所以b应该排在a前面，即a &gt; b;"></a>   ① 若ab &gt; ba ，因为ba小，所以b应该排在a前面，即a &gt; b;</h6><h6 id="②-若ab-lt-ba-，则a-lt-b"><a href="#②-若ab-lt-ba-，则a-lt-b" class="headerlink" title="   ② 若ab &lt; ba ，则a &lt; b;"></a>   ② 若ab &lt; ba ，则a &lt; b;</h6><h6 id="③-若ab-ba-，则a-b"><a href="#③-若ab-ba-，则a-b" class="headerlink" title="   ③ 若ab = ba ，则a = b;"></a>   ③ 若ab = ba ，则a = b;</h6><pre><code>public class RuleSort {

    static String PrintMinNumber(int [] numbers) {

        if(numbers.length == 0 ){
            return &quot;&quot;;
        }

        //1.利用java8 stream将 int数组转为Integer数组
        Integer [] nums = IntStream.of(numbers).parallel().boxed()
                            .collect(Collectors.toList()).toArray(new Integer[numbers.length]);
        //2.根据新规则对原数组进行排序
        Arrays.sort( nums, new Comparator&lt;Integer&gt;(){
            @Override
            public int compare(Integer o1, Integer o2) {
                String A = String.valueOf(o1) + String.valueOf(o2);
                String B = String.valueOf(o2) + String.valueOf(o1);
                return A.compareTo(B);
            }
        });
        //3.将排序后的数组拼接输出即可
        String re = Arrays.stream(nums).parallel().map(n-&gt; n.toString()).collect(Collectors.joining(&quot;&quot;));

        return re;
    }</code></pre><h2 id="数组之数组中的逆序对【归并规划】"><a href="#数组之数组中的逆序对【归并规划】" class="headerlink" title="数组之数组中的逆序对【归并规划】"></a>数组之数组中的逆序对【归并规划】</h2><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组-求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。-即输出P-1000000007"><a href="#在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组-求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。-即输出P-1000000007" class="headerlink" title="  在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007"></a>  在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</h6><pre><code>public int SplitAndMerge(int [] array, int left, int right, int [] temp) {
    //校验
    if(array == null || array.length == 0 ) return 0;
    //终止条件
    if(left &lt; right){
        //1.切分过程
        int mid = (left + right) &gt;&gt; 1; //切分点
        int leftCount = SplitAndMerge(array, left, mid, temp)%1000000007;
        int rightCount = SplitAndMerge(array, mid+1, right, temp)%1000000007;

        //2.合并过程
        int count = 0;//逆序对的计数
        int i = left;  //左子序列的指针
        int j = mid +1;//右子序列的指针
        int t = 0 ;       //临时数组的指针，空间换时间
        while(i &lt;= mid &amp;&amp; j &lt;= right){
            if(array[i] &lt;= array[j]){
                temp[t++] = array[i++];
            }
            else{
                temp[t++] = array[j++];
                //★核心理解：归并排序中2个子序列是升序从小到大进行比较的
                //若array[i] &gt; array[j]，则array[i] ~ array[mid]都会大于arr[j]，所以都属于逆序对
                count += mid - i +1 ;
                if(count &gt;= 1000000007){
                    count = count % 1000000007;
                }
            }
        }
        while(i &lt;= mid){
            temp[t++] = array[i++];
        }
        while(j &lt;= right){
            temp[t++] = array[j++];
        }

        t=0;
        //将temp数组copy回原数组
        while(left &lt;= right){
            array[left++] = temp[t++];
        }

        return (leftCount + rightCount + count)%1000000007;
    }

    return 0;
}</code></pre><h2 id="数字在排序数组中出现的次数【二分查找】"><a href="#数字在排序数组中出现的次数【二分查找】" class="headerlink" title="数字在排序数组中出现的次数【二分查找】"></a>数字在排序数组中出现的次数【二分查找】</h2><h6 id="一搬情况下，排序数组中的查找都可以通过二分查找来解决。"><a href="#一搬情况下，排序数组中的查找都可以通过二分查找来解决。" class="headerlink" title="一搬情况下，排序数组中的查找都可以通过二分查找来解决。"></a>一搬情况下，排序数组中的查找都可以通过二分查找来解决。</h6><h6 id="①-通过二分查找查找k-分别找到第一次出现的位置和最后一次出现的索引位置。"><a href="#①-通过二分查找查找k-分别找到第一次出现的位置和最后一次出现的索引位置。" class="headerlink" title="  ① 通过二分查找查找k,分别找到第一次出现的位置和最后一次出现的索引位置。"></a>  ① 通过二分查找查找k,分别找到第一次出现的位置和最后一次出现的索引位置。</h6><h6 id="②-通过k出现的第一和最后的位置直接计算出现次数即可，last-first-1。"><a href="#②-通过k出现的第一和最后的位置直接计算出现次数即可，last-first-1。" class="headerlink" title="  ② 通过k出现的第一和最后的位置直接计算出现次数即可，last - first +1。"></a>  ② 通过k出现的第一和最后的位置直接计算出现次数即可，last - first +1。</h6><h6 id="③-二分值mid的三种情况："><a href="#③-二分值mid的三种情况：" class="headerlink" title="  ③ 二分值mid的三种情况："></a>  ③ 二分值mid的三种情况：</h6><p>​    mid &gt; k ,k出现在左子树，只在左子树中查找<br>​    mid &lt; k ,k出现在右子树，只在右子树中查找<br>​    mid = k, 判断k是不是一个k或最后一个k<br>​    若k的前一个元素还是等于k，则在左子树中继续二分查找<br>​    同理，k的后一个元素还是等于k，则在右子树中继续二分查找    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">private static int GetNumberOfK(int [] array, int k) &#123;</span><br><span class="line">	if(array &#x3D;&#x3D; null &amp;&amp; array.length &#x3D;&#x3D; 0) return -1;</span><br><span class="line">	</span><br><span class="line">	int first &#x3D; getFirstK(array, 0, array.length-1, k);</span><br><span class="line">	int last &#x3D; getLastK(array, 0, array.length-1, k);</span><br><span class="line">	</span><br><span class="line">	if(first &gt; -1 &amp;&amp; last &gt; -1)&#123;</span><br><span class="line">		return last - first + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">		查找k最后一次出现的位置</span><br><span class="line">	static int getFirstK(int [] arr,int left ,int right,int k)&#123;</span><br><span class="line">		if(arr &#x3D;&#x3D; null &amp;&amp; arr.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;终止条件</span><br><span class="line">		while(left &lt;&#x3D; right)&#123;</span><br><span class="line">			int midIndex &#x3D; (left + right) &gt;&gt; 1;</span><br><span class="line">			if(arr[midIndex] &gt; k)&#123;</span><br><span class="line">				right &#x3D; midIndex - 1;</span><br><span class="line">			&#125;</span><br><span class="line">			else if(arr[midIndex] &lt; k)&#123;</span><br><span class="line">				left &#x3D; midIndex + 1;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;如果mid等于k，且前一个元素不等于k，说明k是第一次出现，返回索引</span><br><span class="line">			else&#123;</span><br><span class="line">				&#x2F;&#x2F; midIndex &gt; 0 防止 arr[midIndex-1] 数组下标越界</span><br><span class="line">				if((midIndex &gt; 0 &amp;&amp; arr[midIndex -1] !&#x3D; k) || midIndex &#x3D;&#x3D; 0)&#123;</span><br><span class="line">					return midIndex;</span><br><span class="line">				&#125;</span><br><span class="line">				else&#123;&#x2F;&#x2F;如果前一个元素也跟k相等，则在前面子序列中二分查找</span><br><span class="line">					right &#x3D; midIndex - 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	查找k最后一次出现的位置</span><br><span class="line">	static int getLastK(int [] arr,int left ,int right,int k)&#123;</span><br><span class="line">		if(arr &#x3D;&#x3D; null &amp;&amp; arr.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;终止条件</span><br><span class="line">		while(left &lt;&#x3D; right)&#123;</span><br><span class="line">			int midIndex &#x3D; (left + right) &gt;&gt; 1;</span><br><span class="line">			if(arr[midIndex] &gt; k)&#123;</span><br><span class="line">				right &#x3D; midIndex - 1;</span><br><span class="line">			&#125;</span><br><span class="line">			else if(arr[midIndex] &lt; k)&#123;</span><br><span class="line">				left &#x3D; midIndex + 1;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;如果mid等于k，且后一个元素不等于k，说明k是最后一次出现，返回索引</span><br><span class="line">			else&#123;</span><br><span class="line">				&#x2F;&#x2F; midIndex &lt; arr.length -1 防止 arr[midIndex+1] 数组下标越界</span><br><span class="line">				if((midIndex &lt; arr.length -1 &amp;&amp; arr[midIndex +1] !&#x3D; k) || midIndex &#x3D;&#x3D; arr.length -1)&#123;</span><br><span class="line">					return midIndex;</span><br><span class="line">				&#125;</span><br><span class="line">				else&#123;&#x2F;&#x2F;如果后一个元素也跟k相等，则在后面子序列中二分查找</span><br><span class="line">					left &#x3D; midIndex + 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组之数组中只出现一次的数字【位运算，异或】"><a href="#数组之数组中只出现一次的数字【位运算，异或】" class="headerlink" title="数组之数组中只出现一次的数字【位运算，异或】"></a>数组之数组中只出现一次的数字【位运算，异或】</h2><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。"><a href="#一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。" class="headerlink" title="  一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。"></a>  一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</h6><p>  ① 异或操作满足交换结合律，比如A ^ B ^ A = B ^ (A ^A) = B ^ 0 = B。所以，数组中数字两两异或，若其中有2个单次出现的数字，最后得到的结果就是这2个单次数字的异或结果，其他出现2次的数字都异或抵消掉了。<br>  ② 通过①的分析，假设数组中只有一个单次的数字，那么异或后的结果就是这个数，所以，考虑把原数组分开，通过什么分开呢？<strong>原数组异或结果位数为1的索引值，区分开2个单次的数，最后分别求2个子数组异或的结果即可。</strong></p>
<pre><code>public class NumXOR {
public static void main(String[] args) {

    int [] array = {2,4,3,6,3,2,5,5};
    int[] num1 = new int[array.length];
    int[] num2 = new int[array.length];
    findNumsAppearOnce(array, num1, num2);

    System.out.println(num1[0] + &quot;  &quot; + num2[0]);
}

/**
 * 
 * @param array
 * @param num1 存放返回结果
 * @param num2
 */
static void findNumsAppearOnce(int [] array,int num1[] , int num2[]){
    if(array == null || array.length == 0){
        num1[0] = -1;
        num2[0] = -1;
    }
    //1. 求原数组两两异或结果
    int bitResult = 0;
    for(int i =0 ; i &lt; array.length; i++){
        bitResult ^= array[i];
    }

    //2. 找到倒数第一个1的位置
    int index = findFirst1(bitResult);

    //3. 根据index位上是不是1切分原数组，并将子数组两两异或。
    for(int i =0 ; i &lt; array.length; i++){
        if(isBit1(array[i],index)){
            num1[0] ^= array[i];
        }
        else{
            num2[0] ^= array[i];
        }
    }

    //4. 最终得到单次出现数字num1[0] num2[0]
}
/**
 * 找到原数组异或结果的倒数第一个1的位置
 * @param bitResult
 * @return
 */
static int findFirst1(int bitResult){
    int index = 0;
    while((bitResult &amp; 1) == 0){
        bitResult &gt;&gt;= 1;
        index++;
    }

    return index;
}

/**
 * 判断数字第index位置上是不是1
 * @param target
 * @param index
 * @return
 */
static boolean isBit1(int target, int index){

    return ((target &gt;&gt; index) &amp; 1) == 1;
}
}</code></pre><h2 id="数组之数组中重复的数字"><a href="#数组之数组中重复的数字" class="headerlink" title="数组之数组中重复的数字"></a>数组之数组中重复的数字</h2><p>  <strong>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</strong>  </p>
<p>  （1）hash数组的下标，就可以用来记录numbers的元素，0-n-1。</p>
<p>  （2）hash数组的下标对应的值，就可以用来记录numbers的元素出现的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean duplicate(int numbers[], int length, int[] duplication) &#123;</span><br><span class="line">		if (numbers &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">			if (numbers[i] &lt; 0 || numbers[i] &gt; length - 1) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 利用数组的数字不超过n-1的特性，创建一个hash数组</span><br><span class="line">		&#x2F;&#x2F; hash数组的下标记为0-n-1，下标对应的值，则是出现的次数</span><br><span class="line">		int[] hash &#x3D; new int[length];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">			hash[numbers[i]]++;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">			if (hash[i] &gt; 1) &#123;</span><br><span class="line">				duplication[0] &#x3D; i;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组之构建乘积数组"><a href="#数组之构建乘积数组" class="headerlink" title="数组之构建乘积数组"></a>数组之构建乘积数组</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><h6 id="给定一个数组A-0-1-…-n-1-请构建一个数组B-0-1-…-n-1-其中B中的元素B-i-A-0-A-1-…A-i-1-A-i-1-…A-n-1-。不能使用除法。"><a href="#给定一个数组A-0-1-…-n-1-请构建一个数组B-0-1-…-n-1-其中B中的元素B-i-A-0-A-1-…A-i-1-A-i-1-…A-n-1-。不能使用除法。" class="headerlink" title="  给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。"></a>  给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static int[] multiply(int[] A) &#123;</span><br><span class="line">        int length &#x3D; A.length;</span><br><span class="line">        int[] B &#x3D; new int[length];</span><br><span class="line">        if(length !&#x3D; 0 )&#123;</span><br><span class="line">            B[0] &#x3D; 1; </span><br><span class="line">            &#x2F;&#x2F;计算下三角连乘，从正数第二行开始 i&#x3D;1</span><br><span class="line">            for(int i &#x3D; 1; i &lt;&#x3D; length -1 ; i++)&#123;</span><br><span class="line">                B[i] &#x3D; B[i-1] * A[i-1]; &#x2F;&#x2F;此时的B就是分析中的C</span><br><span class="line">            &#125;</span><br><span class="line">            int tempD &#x3D; 1;&#x2F;&#x2F;length -1 位置上的值</span><br><span class="line">            &#x2F;&#x2F;计算上三角, 从倒数第二行开始 j&#x3D;length-2</span><br><span class="line">            for(int i &#x3D; length-2; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">            	tempD &#x3D; tempD * A[i+1]; &#x2F;&#x2F;D &#x3D; D[i+1] * A[i+1], 当i&#x3D;length-2时，D[i+1] &#x3D; length -1 位置上的值 tempD &#x3D; 1</span><br><span class="line">                B[i]  &#x3D; B[i] * tempD;   &#x2F;&#x2F;B &#x3D; C * D</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return B;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/04/03/%E6%95%B0%E7%BB%84/">
    <time datetime="2020-04-03T13:49:49.000Z" class="entry-date">
        2020-04-03
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a></li></ul>

    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="prev"><span class="meta-nav">←</span> 字符串</a></span>
    
    
        <span class="nav-next"><a href="/2020/04/03/%E9%93%BE%E8%A1%A8/" rel="next">链表 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2020/04/03/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
          </li>
        
          <li>
            <a href="/2020/04/03/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
          </li>
        
          <li>
            <a href="/2020/04/03/%E6%95%B0%E7%BB%84/">数组</a>
          </li>
        
          <li>
            <a href="/2020/04/03/%E9%93%BE%E8%A1%A8/">链表</a>
          </li>
        
          <li>
            <a href="/2020/01/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-JUC/" rel="tag">Java JUC</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a><span class="tag-list-count">4</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/Java-JUC/" style="font-size: 10px;">Java JUC</a> <a href="/tags/%E5%89%91%E6%8C%87offer/" style="font-size: 10px;">剑指offer</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 张果果的博客
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>